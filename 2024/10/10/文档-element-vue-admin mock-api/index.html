<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>文档-element-vue-admin官方文档mock-api | haipeiface.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Mock DataMock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。 Swagger在公司的项目中通常使用 swagger， 由后端来模拟业务数据。 swagger 是一个 REST APIs 文档生成工具，它从代码注释中自动生成文档，可以跨平台，开源，支持大部分语言">
<meta property="og:type" content="article">
<meta property="og:title" content="文档-element-vue-admin官方文档mock-api">
<meta property="og:url" content="http://example.com/2024/10/10/%E6%96%87%E6%A1%A3-element-vue-admin%20mock-api/index.html">
<meta property="og:site_name" content="haipeiface.github.io">
<meta property="og:description" content="Mock DataMock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。 Swagger在公司的项目中通常使用 swagger， 由后端来模拟业务数据。 swagger 是一个 REST APIs 文档生成工具，它从代码注释中自动生成文档，可以跨平台，开源，支持大部分语言">
<meta property="og:locale">
<meta property="article:published_time" content="2024-10-09T19:31:38.000Z">
<meta property="article:modified_time" content="2024-11-30T09:50:27.360Z">
<meta property="article:author" content="haipeiface">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="haipeiface.github.io" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">haipeiface.github.io</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-文档-element-vue-admin mock-api" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/%E6%96%87%E6%A1%A3-element-vue-admin%20mock-api/" class="article-date">
  <time class="dt-published" datetime="2024-10-09T19:31:38.000Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      文档-element-vue-admin官方文档mock-api
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Mock-Data"><a href="#Mock-Data" class="headerlink" title="Mock Data"></a>Mock Data</h1><p>Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。</p>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p>在公司的项目中通常使用 <a target="_blank" rel="noopener" href="https://swagger.io/">swagger</a>， 由后端来模拟业务数据。 <strong>swagger</strong> 是一个 REST APIs 文档生成工具，它从代码注释中自动生成文档，可以跨平台，开源，支持大部分语言，社区好，总之非常不错，强烈推荐。 <a target="_blank" rel="noopener" href="http://petstore.swagger.io/?_ga=2.222649619.983598878.1509960455-2044209180.1509960455#/pet/addPet">线上 demo</a></p>
<h2 id="Easy-Mock"><a href="#Easy-Mock" class="headerlink" title="Easy-Mock"></a>Easy-Mock</h2><p><a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-admin-template">vue-admin-template</a> 之前使用的是 <a target="_blank" rel="noopener" href="https://easy-mock.com/login">easy-mock</a> 来模拟数据。 它是一个纯前端可视化，并且能快速生成模拟数据的持久化服务。非常的简单易用还能结合 <code>swagger</code>，天然支持跨域 ，不管团队还是个人项目都值得一试。</p>
<p>::: warning 现在线上版本的<code>vue-admin-template</code> 已经不使用<code>easy-mock</code>。因为<code>easy-mock</code>提供的线上免费服务很不稳定，时不时的就会挂掉，如果有需要的可以自己按照它的教程，搭建自己的服务。 :::</p>
<h2 id="Mockjs"><a href="#Mockjs" class="headerlink" title="Mockjs"></a>Mockjs</h2><p>由于 <a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin">vue-element-admin</a> 是一个纯前端个人项目，所有的数据都是用 <a target="_blank" rel="noopener" href="https://github.com/nuysoft/Mock">mockjs</a> 模拟生成。它的原理是: 拦截了所有的请求并代理到本地，然后进行数据模拟，所以你会发现 <code>network</code> 中没有发出任何的请求。</p>
<p>但它的最大的问题是就是它的实现机制。它会重写浏览器的<code>XMLHttpRequest</code>对象，从而才能拦截所有请求，代理到本地。大部分情况下用起来还是蛮方便的，但就因为它重写了<code>XMLHttpRequest</code>对象，所以比如<code>progress</code>方法，或者一些底层依赖<code>XMLHttpRequest</code>的库都会和它发生不兼容，可以看一下我项目的<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/issues?utf8=%E2%9C%93&q=mock">issues</a>，就知道多少人被坑了。</p>
<p>它还有一个问题是，因为是它本地模拟的数据，实际上不会走任何网络请求。所以本地调试起来很蛋疼，只能通过<code>console.log</code>来调试。就拿<code>vue-element-admin</code>来说，想搞清楚 <code>getInfo()</code>接口返回了什么数据，只能通过看源码或者手动 <code>Debug</code> 才能知道。</p>
<h2 id="新方案"><a href="#新方案" class="headerlink" title="新方案"></a>新方案</h2><p>在<code>v4.0</code>版本之后，在本地会启动一个<code>mock-server</code>来模拟数据，线上环境还是继续使用<code>mockjs</code>来进行模拟(因为本项目是一个纯前端项目，你也可以自己搭建一个线上 server 来提供数据)。不管是本地还是线上所有的数据模拟都是基于<code>mockjs</code>生成的，所以只要写一套 mock 数据，就可以在多环境中使用。</p>
<p>该方案的好处是，在保留 <code>mockjs</code>的优势的同时，解决之前的痛点。由于我们的 mock 是完全基于<code>webpack-dev-serve</code>来实现的，所以在你启动前端服务的同时，<code>mock-server</code>就会自动启动，而且这里还通过 <a target="_blank" rel="noopener" href="https://github.com/paulmillr/chokidar">chokidar</a> 来观察 <code>mock</code> 文件夹内容的变化。在发生变化时会清除之前注册的<code>mock-api</code>接口，重新动态挂载新的接口，从而支持热更新。有兴趣的可以自己看一下代码<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/mock/mock-server.js">mock-server.js</a>。由于是一个真正的<code>server</code>，所以你可以通过控制台中的<code>network</code>，清楚的知道接口返回的数据结构。并且同时解决了之前<code>mockjs</code>会重写 <code>XMLHttpRequest</code>对象，导致很多第三方库失效的问题。</p>
<p>本项目的所有请求都是通过封装的<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/utils/request.js">request.js</a>进行发送的，通过阅读源码可以发现所有的请求都设置了一个<code>baseURL</code>，而这个<code>baseURL</code>又是通过读取<code>process.env.VUE_APP_BASE_API</code>这个环境变量来动态设置的，这样方便我们做到不同环境使用不同的 <code>api</code> 地址。</p>
<h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>如果你不想使用<code>mock-server</code>的话只要在<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/vue.config.js">vue.config.js</a>中移除<code>webpack-dev-server</code>中<code>proxy</code>和<code>after</code>这个<code>Middleware</code>就可以了。</p>
<p>现在默认情况下本地的请求会代理到<code>http://localhost:$&#123;port&#125;/mock</code>下，如果你想调整为自己的 mock 地址可以修改 <code>proxy</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  // change xxx-api/login =&gt; mock/login</span><br><span class="line">  // detail: https://cli.vuejs.org/config/#devserver-proxy</span><br><span class="line">  [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">    target: `http://localhost:$&#123;port&#125;/mock`,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      [&#x27;^&#x27; + process.env.VUE_APP_BASE_API]: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">after: require(&#x27;./mock/mock-server.js&#x27;)</span><br></pre></td></tr></table></figure>



<p>:::tip <strong>请注意：该操作需要重启服务</strong> :::</p>
<p><code>mock-server</code>只会在开发环境中使用，线上生产环境目前使用<code>MockJs</code>进行模拟。如果不需要请移除。具体代码：<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/main.js">main.js</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mockXHR &#125; from &#x27;../mock&#x27;</span><br><span class="line">if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;</span><br><span class="line">  mockXHR()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>如果你想添加 mock 数据，只要在根目录下找到<code>mock</code>文件，添加对应的路由，对其进行拦截和模拟数据即可。</p>
<p>比如我现在在<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/api/article.js">src&#x2F;api&#x2F;article</a>中需要添加一个查询某篇文章下面评论数的接口<code>fetchComments</code>，首先新建接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export function fetchComments(id) &#123;</span><br><span class="line">  return request(&#123;</span><br><span class="line">    url: `/article/$&#123;id&#125;/comments`,</span><br><span class="line">    method: &#x27;get&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>声明完接口之后，我们需要找到对应的 mock 文件夹<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/mock/article.js">mock&#x2F;article.js</a>，在下面创建一个能拦截路由的 mock 接口</p>
<p><strong>请注意，mock 拦截是基于路由来做的，请确保 mock 数据一定能匹配你的 api 路由，支持正则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// fetchComments 的 mock</span><br><span class="line">&#123;</span><br><span class="line">  // url 必须能匹配你的接口路由</span><br><span class="line">  // 比如 fetchComments 对应的路由可能是 /article/1/comments 或者 /article/2/comments</span><br><span class="line">  // 所以你需要通过正则来进行匹配</span><br><span class="line">  url: &#x27;/article/[A-Za-z0-9]/comments&#x27;,</span><br><span class="line">  type: &#x27;get&#x27;, // 必须和你接口定义的类型一样</span><br><span class="line">  response: (req, res) =&gt; &#123;</span><br><span class="line">    // 返回的结果</span><br><span class="line">    // req and res detail see</span><br><span class="line">    // https://expressjs.com/zh-cn/api.html#req</span><br><span class="line">    return &#123;</span><br><span class="line">      code: 20000,</span><br><span class="line">      data: &#123;</span><br><span class="line">        status: &#x27;success&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>最常见的操作就是：你本地模拟了了一些数据，待后端完成接口后，逐步替换掉原先 mock 的接口。</p>
<p>我们以<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/api/role.js">src&#x2F;api&#x2F;role.js</a>中的<code>getRoles</code>接口为例。它原本是在<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/mock/role/index.js">mock&#x2F;role&#x2F;index.js</a>中 mock 的数据。现在我们需要将它切换为真实后端数据，只要在<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/mock/role/index.js">mock&#x2F;role&#x2F;index.js</a>找到对应的路由，之后将它删除即可。这时候你可以在<code>network</code>中，查看到真实的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// api 中声明的路由</span><br><span class="line">export function getRoles() &#123;</span><br><span class="line">  return request(&#123;</span><br><span class="line">    url: &#x27;/roles&#x27;,</span><br><span class="line">    method: &#x27;get&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//找到对应的路由，并删除</span><br><span class="line">&#123;</span><br><span class="line">    url: &#x27;/roles&#x27;,</span><br><span class="line">    type: &#x27;get&#x27;,</span><br><span class="line">    response: _ =&gt; &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        code: 20000,</span><br><span class="line">        data: roles</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<h2 id="多个-server"><a href="#多个-server" class="headerlink" title="多个 server"></a>多个 server</h2><p>目前项目只启动了一个<code>mock-server</code>，当然你也可以有自己其它的<code>mock-server</code>或者代理接口。可以一部分接口走这个服务，另一些接口走另一个服务。只需要将它们分别设置不同的的<code>baseURL</code>即可。 <a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/utils/request.js">@&#x2F;utils&#x2F;request.js</a></p>
<p>之后根据设置的 url 规则在 <a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/vue.config.js">vue.config.js</a> 中配置多个 <code>proxy</code> 。</p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/dev-server/#devserver-proxy">相关文档</a></p>
<h2 id="启用纯前端-Mock"><a href="#启用纯前端-Mock" class="headerlink" title="启用纯前端 Mock"></a>启用纯前端 Mock</h2><p>现在在<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/mock/index.js#L19">mock&#x2F;index.js</a>也封装了一个纯前端 mock 的方法，你只需要在<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/tree/master/src">src&#x2F;main.js</a>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mockXHR &#125; from &#x27;../mock&#x27;</span><br><span class="line">mockXHR()</span><br></pre></td></tr></table></figure>



<p>这样就会变成纯前端 mock 数据了和<code>v4.0</code>版本之前的 mock 方案是一样的，原理见上文。目前你看到的线上<a target="_blank" rel="noopener" href="https://panjiachen.github.io/vue-element-admin">demo</a>就是采用该种方式。</p>
<h2 id="本地-Mock-数据与线上数据切换"><a href="#本地-Mock-数据与线上数据切换" class="headerlink" title="本地 Mock 数据与线上数据切换"></a>本地 Mock 数据与线上数据切换</h2><p>有很多时候我们会遇到本地使用 mock 数据，线上环境使用真实数据，或者说不同环境使用不同的数据。</p>
<ul>
<li><strong>Easy-Mock 的形式</strong></li>
</ul>
<p>你需要保证你本地模拟 api 除了根路径其它的地址是一致的。 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://api-dev/login   // 本地请求</span><br><span class="line"></span><br><span class="line">https://api-prod/login  // 线上请求</span><br></pre></td></tr></table></figure>



<p>我们可以通过之后会介绍的<a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin-site/blob/master/zh/guide/essentials/deploy.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a>来做到不同环境下，请求不同的 api 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># .env.development</span><br><span class="line">VUE_APP_BASE_API = &#x27;/dev-api&#x27; #注入本地 api 的根路径</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># .env.production</span><br><span class="line">VUE_APP_BASE_API = &#x27;/prod-api&#x27; #注入线上 api 的根路径</span><br></pre></td></tr></table></figure>



<p>之后根据环境变量创建<code>axios</code>实例，让它具有不同的<code>baseURL</code>。 <a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin/blob/master/src/utils/request.js">@&#x2F;utils&#x2F;request.js</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// create an axios instance</span><br><span class="line">const service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.BASE_API, // api 的 base_url</span><br><span class="line">  timeout: 5000 // request timeout</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>这样我们就做到了自动根据环境变量切换本地和线上 api。</p>
<ul>
<li><strong>Mock.js 的切换</strong></li>
</ul>
<p>当我们本地使用 <code>Mock.js</code> 模拟本地数据，线上使用真实环境 api 方法。这与上面的 easy-mock 的方法是差不多的。我们主要是判断：是线上环境的时候，不引入 mock 数据就可以了，只有在本地引入 <code>Mock.js</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// 通过环境变量来判断是否需要加载启用</span><br><span class="line">if (process.env.NODE_ENV === &#x27;development&#x27;) &#123;</span><br><span class="line">  require(&#x27;./mock&#x27;) // simulation data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只有在本地环境之中才会引入 mock 数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/10/%E6%96%87%E6%A1%A3-element-vue-admin%20mock-api/" data-id="cm43zseag0008bgsl0yko5hsq" data-title="文档-element-vue-admin官方文档mock-api" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/10/%E7%BF%BB%E8%AF%91-Java%20%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          翻译-Java 中的管道设计模式
        
      </div>
    </a>
  
  
    <a href="/2024/10/10/element-vue-admin%E5%89%8D%E7%AB%AFmock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">element-vue-admin前端mock是如何实现的</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/JAVA/" style="font-size: 16.67px;">JAVA</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">后端</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.33px;">设计模式</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/30/%E5%89%8D%E7%AB%AF-%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0token/">前端-无感刷新token</a>
          </li>
        
          <li>
            <a href="/2024/10/29/%E7%BA%AF%E5%8E%9F%E7%94%9Fjs%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E4%BB%BB%E5%8A%A1%E7%9C%8B%E6%9D%BF/">纯原生js简单实现可拖拽任务看板</a>
          </li>
        
          <li>
            <a href="/2024/10/10/%E7%BF%BB%E8%AF%91-Java%20%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">翻译-Java 中的管道设计模式</a>
          </li>
        
          <li>
            <a href="/2024/10/10/%E6%96%87%E6%A1%A3-element-vue-admin%20mock-api/">文档-element-vue-admin官方文档mock-api</a>
          </li>
        
          <li>
            <a href="/2024/10/10/element-vue-admin%E5%89%8D%E7%AB%AFmock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">element-vue-admin前端mock是如何实现的</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 haipeiface<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>