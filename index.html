<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>haipeiface.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="haipeiface.github.io">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="haipeiface.github.io">
<meta property="og:locale">
<meta property="article:author" content="haipeiface">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="haipeiface.github.io" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">haipeiface.github.io</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-纯原生js简单实现可拖拽任务看板" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/29/%E7%BA%AF%E5%8E%9F%E7%94%9Fjs%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E4%BB%BB%E5%8A%A1%E7%9C%8B%E6%9D%BF/" class="article-date">
  <time class="dt-published" datetime="2024-10-29T03:12:04.000Z" itemprop="datePublished">2024-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/29/%E7%BA%AF%E5%8E%9F%E7%94%9Fjs%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E4%BB%BB%E5%8A%A1%E7%9C%8B%E6%9D%BF/">纯原生js简单实现可拖拽任务看板</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>看板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.kanban-board</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">overflow-x</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.kanban-column</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#f4f5f7</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.kanban-card</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">9</span>, <span class="number">30</span>, <span class="number">66</span>, <span class="number">0.25</span>);</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">cursor</span>: move;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;kanban-board&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;kanban-column&quot;</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>待办事项<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;task1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kanban-card&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span>&gt;</span>任务 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;task2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kanban-card&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span>&gt;</span>任务 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;kanban-column&quot;</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>进行中<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;task3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kanban-card&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span>&gt;</span>任务 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;kanban-column&quot;</span> <span class="attr">ondragover</span>=<span class="string">&quot;event.preventDefault()&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>已完成<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;task4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kanban-card&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span>&gt;</span>任务 4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            event.<span class="property">dataTransfer</span>.<span class="title function_">setData</span>(<span class="string">&quot;text&quot;</span>, event.<span class="property">target</span>.<span class="property">id</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">drop</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> data = event.<span class="property">dataTransfer</span>.<span class="title function_">getData</span>(<span class="string">&quot;text&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> card = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(data);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;kanban-column&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">                event.<span class="property">target</span>.<span class="title function_">appendChild</span>(card);</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;kanban-card&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">                event.<span class="property">target</span>.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(card, event.<span class="property">target</span>.<span class="property">nextSibling</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><strong>拖拽属性</strong>：每个任务卡片（kanban-card）设置了 draggable&#x3D;”true”，使其可以被拖动。</p>
<p><strong>事件处理</strong>：</p>
<p><code>ondragstart</code>：在拖动开始时触发，使用 <code>event.dataTransfer.setData</code> 存储被拖动元素的 ID。</p>
<p><code>ondragover</code>：在拖动元素悬停在目标元素上时触发，使用 <code>event.preventDefault()</code> 允许放置。</p>
<p><code>ondrop</code>：在放置时触发，使用 <code>event.dataTransfer.getData</code> 获取被拖动元素的 ID，并将其附加到目标元素。</p>
<p><strong>注意</strong>：确保每个卡片有唯一的 <code>id</code>，以便在拖放操作中正确识别。您可以在生成卡片时动态分配 ID。</p>
<p><strong>拖放逻辑</strong>：</p>
<p><code>ondrop</code> 事件中，首先检查放置目标是否是一个列（kanban-column），如果是，则将卡片附加到该列。</p>
<p>如果放置目标是另一个卡片（kanban-card），则将拖动的卡片插入到目标卡片的后面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/29/%E7%BA%AF%E5%8E%9F%E7%94%9Fjs%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E4%BB%BB%E5%8A%A1%E7%9C%8B%E6%9D%BF/" data-id="cm42pghe90007ogsl5m6f1ozr" data-title="纯原生js简单实现可拖拽任务看板" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-element-vue-admin前端mock是如何实现的" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/10/element-vue-admin%E5%89%8D%E7%AB%AFmock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" class="article-date">
  <time class="dt-published" datetime="2024-10-09T18:57:20.000Z" itemprop="datePublished">2024-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/10/element-vue-admin%E5%89%8D%E7%AB%AFmock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">element-vue-admin前端mock是如何实现的</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>项目中的mock功能是基于<code>mockjs</code> 实现的。</p>
<ol>
<li>mock数据存放在各自modules里，每个module导出一个array，包括url，http方法，返回函数或object。</li>
</ol>
<p>例如：<code>mock/remote-search.js</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = [</span><br><span class="line">  <span class="comment">// username search</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/vue-element-admin/search/user&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">response</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; name &#125; = config.<span class="property">query</span></span><br><span class="line">      <span class="keyword">const</span> mockNameList = <span class="title class_">NameList</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> lowerCaseName = item.<span class="property">name</span>.<span class="title function_">toLowerCase</span>()</span><br><span class="line">        <span class="keyword">return</span> !(name &amp;&amp; lowerCaseName.<span class="title function_">indexOf</span>(name.<span class="title function_">toLowerCase</span>()) &lt; <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="number">20000</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123; <span class="attr">items</span>: mockNameList &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>mock server: 定义在<code>mock/mock-server.js</code> 中，使用 <code>chokidar</code>来watch文件目录并对进来的请求进行body-parser。 <code>registerRoutes</code>  用来注册mock routes。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerRoutes</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> mockLastIndex</span><br><span class="line">  <span class="keyword">const</span> &#123; mocks &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> mocksForServer = mocks.<span class="title function_">map</span>(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">responseFake</span>(route.<span class="property">url</span>, route.<span class="property">type</span>, route.<span class="property">response</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> mock <span class="keyword">of</span> mocksForServer) &#123;</span><br><span class="line">    app[mock.<span class="property">type</span>](mock.<span class="property">url</span>, mock.<span class="property">response</span>)</span><br><span class="line">    mockLastIndex = app.<span class="property">_router</span>.<span class="property">stack</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> mockRoutesLength = <span class="title class_">Object</span>.<span class="title function_">keys</span>(mocksForServer).<span class="property">length</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">mockRoutesLength</span>: mockRoutesLength,</span><br><span class="line">    <span class="attr">mockStartIndex</span>: mockLastIndex - mockRoutesLength</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>Mock XHR：<code>mock/index.js</code> 中，<code>mockXHR </code> 重新定义了<code>XMLHttpRequest</code> 用来拦截requests并提供mock response。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mockXHR</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// mock patch</span></span><br><span class="line">  <span class="comment">// https://github.com/nuysoft/Mock/issues/300</span></span><br><span class="line">  <span class="title class_">Mock</span>.<span class="property">XHR</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">proxy_send</span> = <span class="title class_">Mock</span>.<span class="property">XHR</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span></span><br><span class="line">  <span class="title class_">Mock</span>.<span class="property">XHR</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">custom</span>.<span class="property">xhr</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">custom</span>.<span class="property">xhr</span>.<span class="property">withCredentials</span> = <span class="variable language_">this</span>.<span class="property">withCredentials</span> || <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">responseType</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">custom</span>.<span class="property">xhr</span>.<span class="property">responseType</span> = <span class="variable language_">this</span>.<span class="property">responseType</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">proxy_send</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">XHR2ExpressReqWrap</span>(<span class="params">respond</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (respond <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; body, type, url &#125; = options</span><br><span class="line">        <span class="comment">// https://expressjs.com/en/4x/api.html#req</span></span><br><span class="line">        result = <span class="title function_">respond</span>(&#123;</span><br><span class="line">          <span class="attr">method</span>: type,</span><br><span class="line">          <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">parse</span>(body),</span><br><span class="line">          <span class="attr">query</span>: <span class="title function_">param2Obj</span>(url)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = respond</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Mock</span>.<span class="title function_">mock</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> mocks) &#123;</span><br><span class="line">    <span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(i.<span class="property">url</span>), i.<span class="property">type</span> || <span class="string">&#x27;get&#x27;</span>, <span class="title class_">XHR2ExpressReqWrap</span>(i.<span class="property">response</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>集成进vue中，在src&#x2F;main.js中，mockXHR在prod环境中才被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; mockXHR &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../mock&#x27;</span>)</span><br><span class="line">  <span class="title function_">mockXHR</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>其他：Utility Functions像<code>param2Obj</code>被用来解析请求参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">url</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">param2Obj</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> search = <span class="built_in">decodeURIComponent</span>(url.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]).<span class="title function_">replace</span>(<span class="regexp">/\+/g</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (!search) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> searchArr = search.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  searchArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = v.<span class="title function_">indexOf</span>(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> name = v.<span class="title function_">substring</span>(<span class="number">0</span>, index)</span><br><span class="line">      <span class="keyword">const</span> val = v.<span class="title function_">substring</span>(index + <span class="number">1</span>, v.<span class="property">length</span>)</span><br><span class="line">      obj[name] = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/10/element-vue-admin%E5%89%8D%E7%AB%AFmock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" data-id="cm42pghe60003ogsledibf430" data-title="element-vue-admin前端mock是如何实现的" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Disruptor在撮合引擎的实践｜得物技术" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/Disruptor%E5%9C%A8%E6%92%AE%E5%90%88%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BD%9C%E5%BE%97%E7%89%A9%E6%8A%80%E6%9C%AF/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T01:26:42.000Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/08/Disruptor%E5%9C%A8%E6%92%AE%E5%90%88%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BD%9C%E5%BE%97%E7%89%A9%E6%8A%80%E6%9C%AF/">Disruptor在撮合引擎的实践｜得物技术</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>目录</strong></p>
<p>一、Disruptor的简介</p>
<ol>
<li>Disruptor的使用场景</li>
<li>Disruptor和ArrayBlockingQueue性能对比</li>
<li>Disruptor快速接入指南</li>
<li>Disruptor消费者等待策略</li>
<li>Disruptor灵活的消费者模式</li>
</ol>
<p>二、Disruptor的核心概念</p>
<ol>
<li>Disruptor内部组件交互图</li>
<li>核心概念</li>
</ol>
<p>三、Disruptor的特点</p>
<ol>
<li>环形数组结构</li>
<li>无锁化设计</li>
<li>独占缓存行的方式消除伪共享</li>
<li>预分配内存</li>
</ol>
<p>四、Disruptor在撮合引擎中的应用</p>
<ol>
<li>数字货币交易系统的简介</li>
<li>撮合引擎流程图</li>
<li>撮合引擎之Disruptor代码</li>
</ol>
<p>五、总结</p>
<p><strong>一</strong></p>
<p><strong>Disruptor的简介</strong></p>
<p>Disruptor是基于事件异步驱动模型实现的，采用了RingBuffer数据结构，支持高并发、低延时、高吞吐量的高性能工作队列，它是由英国外汇交易公司LMAX开发的，研发的初衷是解决内存队列的延迟问题，不同于我们常用的分布式消息中间件RocketMQ、Kafaka，而Disruptor是单机的、本地内存队列，类似JDK的<code>ArrayBlockingQueue</code>等队列。</p>
<p><strong>Disruptor的使用场景</strong></p>
<ul>
<li>加密货币交易撮合引擎</li>
<li>Log4j2基于Disruptor实现的异步日志处理</li>
<li>Canal+Disruptor实现高效的数据同步</li>
<li>知名开源框架Apache Strom</li>
</ul>
<p>2010年在QCon的演讲，介绍了基于Disruptor开发的系统单线程能支撑每秒600万订单，由此可见该组件可以大幅提升系统的TPS，所以对于一些需要大幅提升单机应用的吞吐量的场景可以考虑使用Disruptor。</p>
<p><strong>Disruptor和ArrayBlockingQueue性能对比</strong></p>
<ul>
<li>ArrayBlockingQueue是基于数组ArrayList实现的，通过ReentrantLock独占锁保证线程安全；</li>
<li>Disruptor是基于环形数组队列RingBuffer实现的，通过CAS乐观锁保证线程安全。在多种生产者-消费者模式下的性能对比。</li>
</ul>
<p><img src="/images%5CABQvsDisruptor" alt="图片"></p>
<p><strong>Disruptor快速接入指南</strong></p>
<p><strong>引入Maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>自定义事件和事件工厂</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEvent</span> &#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> value)</span> &#123;        </span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LongEvent&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;  </span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventFactory</span> <span class="keyword">implements</span> <span class="title class_">EventFactory</span>&lt;LongEvent&gt; &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> LongEvent <span class="title function_">newInstance</span><span class="params">()</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LongEvent</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>定义事件处理器，即消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventHandler</span> <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;LongEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LongEvent event, <span class="type">long</span> sequence, <span class="type">boolean</span> endOfBatch)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Event: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>定义事件生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.examples.longevent.LongEvent;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventProducer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> &#123;    </span><br><span class="line">        <span class="built_in">this</span>.ringBuffer = ringBuffer; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(ByteBuffer bb)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> ringBuffer.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">LongEvent</span> <span class="variable">event</span> <span class="operator">=</span> ringBuffer.get(sequence);</span><br><span class="line">            event.set(bb.getLong(<span class="number">0</span>)); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            ringBuffer.publish(sequence);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>编写启动类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongEventMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        <span class="comment">// 消费者线程池  </span></span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();  </span><br><span class="line">        <span class="comment">// 事件工厂     </span></span><br><span class="line">        <span class="type">LongEventFactory</span> <span class="variable">eventFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventFactory</span>();     </span><br><span class="line">        <span class="comment">// 指定RingBuffer大小    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bufferSize</span> <span class="operator">=</span> <span class="number">1024</span>;   </span><br><span class="line">        <span class="comment">// 构造事件分发器    </span></span><br><span class="line">        Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(eventFactory </span><br><span class="line">                                                         , bufferSize        </span><br><span class="line">                                                         , executor        </span><br><span class="line">                                                         , ProducerType.SINGLE <span class="comment">// 1.ProducerType.SINGLE 单生产者模式 											2.ProducerType.MULTI 多生产者模式          </span></span><br><span class="line">                                                         , <span class="keyword">new</span> <span class="title class_">YieldingWaitStrategy</span>());<span class="comment">//消费者等待策略   </span></span><br><span class="line">        <span class="comment">// 注册消费者    </span></span><br><span class="line">        disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler</span>());    </span><br><span class="line">        <span class="comment">// 启动事件分发    </span></span><br><span class="line">        disruptor.start();     </span><br><span class="line">        <span class="comment">// 获取RingBuffer 用于生产事件    </span></span><br><span class="line">        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();      </span><br><span class="line">        <span class="type">LongEventProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventProducer</span>(ringBuffer); 	</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i=<span class="number">0</span>;<span class="literal">true</span>; i++) &#123;       </span><br><span class="line">            bb.putLong(<span class="number">0</span>, i);      </span><br><span class="line">            <span class="comment">// 发送事件        </span></span><br><span class="line">            producer.onData(bb);           </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);     </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>Disruptor消费者等待策略</strong></p>
<p>等待策略WaitStrategy是一种决定一个消费者如何等待生产者将event对象放入Disruptor的方式&#x2F;策略。</p>
<p>下面是常见的4种消费者等待策略：</p>
<p><img src="/images%5C%E6%B6%88%E8%B4%B9%E8%80%85%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5" alt="图片"></p>
<p><strong>Disruptor灵活的消费者模式</strong></p>
<p><strong>支持单生产者和多生产者</strong></p>
<p>构造Disruptor时指定生产者类型即可：ProducerType.SINGLE 和 ProducerType.MULTI</p>
<p><strong>单消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册单个消费者</span></span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler</span>());</span><br></pre></td></tr></table></figure>





<p><strong>多消费者：并行的、广播模式</strong></p>
<p>同一个事件会同时被所有消费者处理，同组内消费者之间不存在竞争关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册多个消费者</span></span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler</span>(), <span class="keyword">new</span> <span class="title class_">LongEventHandler1</span>(), <span class="keyword">new</span> <span class="title class_">LongEventHandler2</span>());</span><br></pre></td></tr></table></figure>





<p><strong>多消费者：并行的、消费者组模式</strong></p>
<p>同组内消费者之间互斥，一个事件只会被同组内单个消费者处理，但可以支持多个消费者组，消费者组之间完全隔离，互不影响，代码实现方式有两点不同之处：</p>
<ul>
<li>消费者需要实现WorkHandler接口，而不是 EventHandler 接口；</li>
<li>使用handleEventsWithWorkerPool设置Disruptor的消费者，而不是handleEventsWith方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongWorkHandler</span>  <span class="keyword">implements</span> <span class="title class_">WorkHandler</span>&lt;LongEvent&gt; &#123;   </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LongEvent longEvent)</span> <span class="keyword">throws</span> Exception &#123;        </span><br><span class="line">        System.out.println(<span class="string">&quot;Event: &quot;</span> + logEvent);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherWorkHandler</span>  <span class="keyword">implements</span> <span class="title class_">WorkHandler</span>&lt;LongEvent&gt; &#123;    		</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LongEvent longEvent)</span> <span class="keyword">throws</span> Exception &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;Event: &quot;</span> + logEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册消费者组</span></span><br><span class="line">disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>()    </span><br><span class="line">                                     , <span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>()    </span><br><span class="line">                                     , <span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>多个消费者组之间并行模式</li>
</ul>
<p><img src="/images%5C%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E5%B9%B6%E8%A1%8C%E6%A8%A1%E5%BC%8F" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册消费者组1</span></span><br><span class="line">disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>()     </span><br><span class="line">	, <span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>()       </span><br><span class="line">	, <span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>());</span><br><span class="line"><span class="comment">//注册消费者组2</span></span><br><span class="line">disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> <span class="title class_">OtherWorkHandler</span>()    </span><br><span class="line">	, <span class="keyword">new</span> <span class="title class_">OtherWorkHandler</span>()      </span><br><span class="line">	, <span class="keyword">new</span> <span class="title class_">OtherWorkHandler</span>());</span><br></pre></td></tr></table></figure>

<ul>
<li>多个消费者组之间航道执行模式</li>
</ul>
<p><img src="/images%5C%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E4%B9%8B%E9%97%B4%E8%88%AA%E9%81%93%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册消费者</span></span><br><span class="line">disruptor.handleEventsWithWorkerPool(<span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>(), </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>(),</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">LongWorkHandler</span>())        	     </span><br><span class="line">    .thenHandleEventsWithWorkerPool(<span class="keyword">new</span> <span class="title class_">OtherWorkHandler</span>(),                                         </span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">OtherWorkHandler</span>(),</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">OtherWorkHandler</span>());</span><br></pre></td></tr></table></figure>





<p><strong>多消费者：链式、菱形、六边形执行模式</strong></p>
<p>通过多种组合方式，可实现灵活的消费者执行顺序，如下：</p>
<p><img src="/images%5C%E7%81%B5%E6%B4%BB%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式</span></span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler11</span>()).then(<span class="keyword">new</span> <span class="title class_">LongEventHandler12</span>());</span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler21</span>()).then(<span class="keyword">new</span> <span class="title class_">LongEventHandler22</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//菱形</span></span><br><span class="line">disruptor.handleEventsWith(<span class="keyword">new</span> <span class="title class_">LongEventHandler1</span>(), <span class="keyword">new</span> <span class="title class_">LongEventHandler2</span>())    .then(<span class="keyword">new</span> <span class="title class_">LongEventHandler3</span>());  </span><br><span class="line"><span class="comment">//六边形</span></span><br><span class="line"><span class="type">LongEventHandler</span> <span class="variable">handler11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventHandler</span>();</span><br><span class="line"><span class="type">LongEventHandler</span> <span class="variable">handler12</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventHandler</span>();</span><br><span class="line"><span class="type">LongEventHandler</span> <span class="variable">handler21</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventHandler</span>();</span><br><span class="line"><span class="type">LongEventHandler</span> <span class="variable">handler22</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventHandler</span>();</span><br><span class="line"><span class="type">LongEventHandler</span> <span class="variable">handler3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongEventHandler</span>();</span><br><span class="line">disruptor.handleEventsWith(handler11, handler21);</span><br><span class="line">disruptor.after(handler11).handleEventsWith(handler12);</span><br><span class="line">disruptor.after(handler21).handleEventsWith(handler22);</span><br><span class="line">disruptor.after(handler12, handler22).handleEventsWith(handler3);</span><br></pre></td></tr></table></figure>





<p><strong>二</strong></p>
<p><strong>Disruptor的核心概念</strong></p>
<p><strong>Disruptor内部组件交互图</strong></p>
<p><img src="/images%5C%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92%E5%9B%BE" alt="图片"></p>
<p> <strong>核心概念</strong></p>
<p>有些概念前面已经介绍过，在此不再赘述，说一说还未介绍的几个概念：</p>
<p><strong>Sequence</strong></p>
<p>Sequence本身就是一个序号管理器，它是严格顺序增长的，Disruptor通过它标识和定位RingBuffer中的每一个事件，每个Consumer都维护一个Sequence，通过Sequence可以跟踪Consumer事件处理进度，它有AtomicLong的大多数功能特性，而且它消除了CPU伪共享的问题。</p>
<p><strong>Sequencer</strong></p>
<p>Sequencer是一个接口，它有两个实现类：SingleProducerSequencer(单生产者实现)、MultiProducerSequencer(多生产者实现)，它主要作用是实现生产者和消费者之间快速、正确传递数据的并发算法。</p>
<p>Sequencer是生产者与缓冲区RingBuffer之间的桥梁。生产者可以通过Sequencer向RingBuffer申请数据的存放空间，并使用publish()方法通过WaiteStrategy通知消费者。</p>
<p><strong>SequenceBarrier（序列屏障）</strong></p>
<p>SequenceBarrier用于保证事件的有序性。它通过维护一组Sequence来跟踪消费者的进度，当生产者发布新的事件时，序列屏障会检查是否所有消费者都已处理完前面的事件，如果是，则通知生产者可以发布新的事件。</p>
<p>SequenceBarrier是消费者与RingBuffer之间的桥梁。在Disruptor中，消费者直接访问的是SequenceBarrier，而不是RingBuffer，因此SequenceBarrier能减少RingBuffer上的并发冲突，当消费者的消费速度大于生产者的生产速度时，消费者就可以通过waitFor()方法给予生产者一定的缓冲时间，从而协调了生产者和消费者的速度问题。</p>
<p>SequenceBarrier同时也是消费者与消费者之间消费依赖的抽象，SequenceBarrier只有一个实现类，即ProcessingSequenceBarrier。ProcessingSequenceBarrier由生产者Sequencer、消费定位cursorSequence、等待策略waitStrategy、还有一组依赖Sequence(dependentSequence)组成。</p>
<p><img src="/images%5CProcessingSequenceBarrier" alt="图片"></p>
<p><strong>三</strong></p>
<p><strong>Disruptor的特点</strong></p>
<p><strong>环形数组结构</strong></p>
<ul>
<li>采用首尾相接的数组而非链表，无需担心index溢出问题，且数组对处理器的缓存机制更加友好；</li>
<li>在RingBuffer数组长度设置为2^N时，通过sequence &amp; (bufferSize-1)加速定位元素实际下标索引，通过结合左移(&lt;&lt;)操作实现乘法；</li>
<li>结合SequenceBarrier机制，实现线程与线程之间高效的数据交互。</li>
</ul>
<p><strong>无锁化设计</strong></p>
<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据，整个过程通过原子变量CAS，保证操作的线程安全，即Disruptor的Sequence的自增就是CAS的自旋自增，对应的ArrayBlockQueue的数组索引index是互斥自增。</p>
<p><strong>独占缓存行的方式消除伪共享</strong></p>
<p><strong>什么是伪共享</strong></p>
<p>出现伪共享问题（False Sharing）的原因：</p>
<ul>
<li>一个缓存行可以存储多个变量（存满当前缓存行的字节数）；64个字节可以放8个long，16个int；</li>
<li>而CPU对缓存的修改又是以缓存行为最小单位的；不是以long 、byte这样的数据类型为单位的；</li>
<li>在多线程情况下，如果需要修改“共享同一个缓存行的其中一个变量”，该行中其他变量的状态就会失效，甚至进行一致性保护。</li>
</ul>
<p>所以，伪共享问题（False Sharing）的本质是：</p>
<p><strong>CPU针对缓存的操作是以Cache Line为基本单位，对缓存行中的单个变量进行修改，会导致整个缓存行其他不相关的数据也都失效了，需要从主存重新加载，这个过程会带来性能损耗。</strong></p>
<p><strong>Disruptor是如何解决伪共享的</strong></p>
<p>Sequence是标识RingBuffer环形数组的下标，同时生产者和消费者也会维护各自的Sequence，最重要的是，<strong>Sequence通过填充CPU缓存行避免了伪共享带来的性能损耗</strong>，来看下其填充缓存行源码：</p>
<p><img src="/images%5CLhsPadding" alt="图片"></p>
<p><strong>预分配内存</strong></p>
<p>环形队列存放的是Event对象，而且是在Disruptor创建的时候调用EventFactory创建并一次将队列填满。Event保存生产者生产的数据，消费者也是通过Event获取数据，后续生产者只需要替换掉Event中的属性值。这种方式避免了重复创建对象，降低JVM的GC频率，带来系统性能的提升。后续我们在做编码的时候其实也可以借鉴这种实现思路。</p>
<p>见com.lmax.disruptor.RingBuffer.fill(EventFactoryeventFactory)</p>
<p><img src="/images%5CfillEventFactory" alt="图片"></p>
<p><strong>四</strong></p>
<p><strong>Disruptor在撮合引擎中的应用</strong></p>
<p><strong>数字货币交易系统的简介</strong></p>
<p>**背景&amp;价值<br>**</p>
<p>为用户提供数字虚拟货币的实时在线交易平台，实现盈亏。</p>
<p>**交易系统简化交互图<br>**</p>
<p>为了便于理解，简单列举交易系统的核心服务和数据流向，见下图：</p>
<p><img src="/images%5C%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91" alt="图片"></p>
<p><strong>撮合应用的特点</strong></p>
<ul>
<li>纯内存的、CPU密集型的</li>
</ul>
<p>应用启动时加载数据库未处理订单、写日志、撮合成功发送消息到MQ会涉及IO操作。</p>
<ul>
<li>有状态的</li>
</ul>
<p>正因为应用是有状态的，所以需要通过Disruptor提升单机的性能和吞吐量。</p>
<h2 id="为什么撮合应用不设计成无状态的？"><a href="#为什么撮合应用不设计成无状态的？" class="headerlink" title="为什么撮合应用不设计成无状态的？"></a>为什么撮合应用不设计成无状态的？</h2><p>在学习或者实际做架构设计时，一般大多数情况都建议将应用设计为无状态的，可以通过水平扩展，实现应用的高可用、高性能。而有状态的应用一般有单点故障问题，难以通过水平扩展提升应用的性能，但是做架构设计的时候，还是需要从实际的场景出发，而撮合应用场景很显然更适合设计成有状态的。在数字加密货币交易平台，每一种数字加密货币都是由唯一的“交易对”去标识的，类似股票交易中的股票代码，针对不同交易对的买卖交易单是天然隔离的，而同种交易对的买卖交易单必须是在同一个应用去处理的，否则匹配撮合的时候是有问题的。如果使用无状态的设计，那么所有的交易对都必须在一个集群内处理，而且每个应用都必须要有全量交易对的订单数据，这样就会存在两个问题：多个应用撮合匹配结果不一致，以哪个为准、热点交易对如何做隔离，所以解决方案就是根据交易对维度对订单做分片，同一个交易对的订单消息路由到同一个撮合应用进行处理，这样其实就是将撮合应用设计成有状态的。每一种交易对每个时刻有且只有一个应用能处理，然后再通过k8s的Liveness和Readiness探针做自动故障转移和恢复来解决单点故障的问题，最后通过本地缓存Caffeine+高性能队列Disruptor提升单pod的吞吐量。16C64G的配置在实际业务场景压测的结果是，单机最大TPS在200w&#x2F;s左右，对于整个交易系统而言性能瓶颈已经不在撮合应用，因为极端情况下可以配置成一个pod处理一个交易对。</p>
<p><strong>撮合引擎流程图</strong></p>
<p>撮合引擎服务核心链路流程图：</p>
<p><img src="/images%5C%E6%92%AE%E5%90%88%E5%BC%95%E6%93%8E%E6%B5%81%E7%A8%8B%E5%9B%BE" alt="图片"></p>
<p><strong>撮合引擎之Disruptor代码</strong></p>
<p>为了便于理解，删除了和Disruptor无关的代码，只列举和Disruptor相关联的代码。</p>
<p><strong>定义事件：用户交易单</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DisruptorEvent</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5886259612924517631L</span>;</span><br><span class="line">    <span class="comment">//成交单    </span></span><br><span class="line">    <span class="keyword">private</span> EntrustOrder entrustOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>定义事件处理器：对用户买单和卖单进行撮合匹配</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//撮合事件处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultsHandler</span> <span class="keyword">implements</span> <span class="title class_">EventHandler</span>&lt;DisruptorEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; symbolIdSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> workerQueueSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultsHandler</span><span class="params">(Set&lt;Integer&gt; symbolIdSet, <span class="type">int</span> queueSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.symbolIdSet.addAll(symbolIdSet);</span><br><span class="line">        <span class="built_in">this</span>.workerQueueSize = queueSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(DisruptorEvent disruptorEvent, <span class="type">long</span> sequence, <span class="type">boolean</span> endOfBatch)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取订单</span></span><br><span class="line">            <span class="type">EntrustOrder</span> <span class="variable">entrustOrder</span> <span class="operator">=</span> disruptorEvent.getEntrustOrder();</span><br><span class="line">      </span><br><span class="line">            <span class="comment">//常规的撮合，正常撤单，异常撤单</span></span><br><span class="line">            <span class="keyword">if</span> (OperationTypeEnum.MATCH.getCode() == entrustOrder.getOperationType() ||</span><br><span class="line">                    OperationTypeEnum.CANCEL.getCode() == entrustOrder.getOperationType()) &#123;</span><br><span class="line">                <span class="comment">// 取消订单需要在引擎内处理</span></span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(entrustOrder.getOperationType(), OperationTypeEnum.MATCH.getCode())) &#123;</span><br><span class="line">                    <span class="comment">//更新为处理中</span></span><br><span class="line">                    OrderBook.addToOrderBook(entrustOrder.getOrderId(), MatchStatusEnum.MATCH_ING);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(entrustOrder.getOperationType(), OperationTypeEnum.CANCEL.getCode())) &#123;</span><br><span class="line">                    <span class="comment">//更新为处理中</span></span><br><span class="line">                    <span class="keyword">if</span> (OrderBook.getByOrderId(entrustOrder.getOrderId()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        OrderBook.addToOrderBook(entrustOrder.getOrderId(), MatchStatusEnum.CANCEL_ING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行撮合</span></span><br><span class="line">                <span class="built_in">this</span>.doMatch(entrustOrder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;match disruptor event handler error:&#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据规则选择不同的撮合策略算法，进行撮合处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> takerOrder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMatch</span><span class="params">(EntrustOrder takerOrder)</span> &#123;</span><br><span class="line">        <span class="type">SideEnum</span> <span class="variable">sideEnum</span> <span class="operator">=</span> SideEnum.getSideEnum(takerOrder.getSide());</span><br><span class="line">        <span class="type">OrderTypeEnum</span> <span class="variable">orderTypeEnum</span> <span class="operator">=</span> OrderTypeEnum.getOrderTypeEnum(takerOrder.getOrderType());</span><br><span class="line">        <span class="comment">//选择撮合策略</span></span><br><span class="line">        <span class="type">MatchService</span> <span class="variable">matchService</span> <span class="operator">=</span> MatchStrategy.router(orderTypeEnum, sideEnum);</span><br><span class="line">        <span class="type">MatchContext</span> <span class="variable">matchContext</span> <span class="operator">=</span> MatchContext.getContext();</span><br><span class="line">        matchContext.setTakerOrder(takerOrder);</span><br><span class="line">        <span class="comment">//执行撮合</span></span><br><span class="line">        matchService.start(matchContext);</span><br><span class="line">        <span class="comment">//撮合完成</span></span><br><span class="line">        matchService.stop(matchContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>事件生产者：构建Disruptor、生产事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * disruptor启动入口类，当系统读取到当前机器需要为哪些交易对提供服务的时候，</span></span><br><span class="line"><span class="comment"> * 我们需要为这些交易对进行分组服务，哪些交易对放到同一个disruptor中</span></span><br><span class="line"><span class="comment"> * 通过分组，一方面确保了活跃度高的交易对能够最大程度的利用资源，另一方面活跃度低的交易对能够有效处理，</span></span><br><span class="line"><span class="comment"> * 同时降低了cpu暴涨的风险</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangeLauncher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">16</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LimitBuyMatchService limitBuyMatchService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LimitSellMatchService limitSellMatchService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MarketBuyMatchService marketBuyMatchService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MarketSellMatchService marketSellMatchService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MatchClusterConfiguration matchClusterConfiguration;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;match.worker-queue-size:5&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> workSize;</span><br><span class="line">    <span class="comment">//一个交易对对应一个disruptor</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ExchangeCore&gt; exchangeCoreMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ExchangeCore&gt; exchangeCoreList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//init order book</span></span><br><span class="line">            OrderBook.init();</span><br><span class="line"></span><br><span class="line">            Set&lt;Integer&gt; symbolIdListSet = matchClusterConfiguration.getMasterSymbolIdSet();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(symbolIdListSet)) &#123;</span><br><span class="line">                List&lt;Integer&gt; allSymbolIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(symbolIdListSet);</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; pageList = ListUtils.partition(allSymbolIds, workSize);</span><br><span class="line">                pageList.forEach(symbolIds -&gt; &#123;</span><br><span class="line">                    <span class="type">ResultsHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultsHandler</span>(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(symbolIds), workSize);</span><br><span class="line">                    <span class="type">ExchangeCore</span> <span class="variable">exchangeCore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExchangeCore</span>(handler, BUFFER_SIZE, <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(<span class="string">&quot;match&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">                    exchangeCore.start();</span><br><span class="line">                    exchangeCoreList.add(exchangeCore);</span><br><span class="line">                    symbolIds.forEach(symbolId -&gt; exchangeCoreMap.put(symbolId, exchangeCore));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注册matchService子类</span></span><br><span class="line">            registerMatchServices();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;exchangeLauncher start error:&#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerMatchServices</span><span class="params">()</span> &#123;</span><br><span class="line">        MatchStrategy.register(OrderTypeEnum.LIMIT, SideEnum.BUY, limitBuyMatchService);</span><br><span class="line">        MatchStrategy.register(OrderTypeEnum.LIMIT, SideEnum.SELL, limitSellMatchService);</span><br><span class="line">        MatchStrategy.register(OrderTypeEnum.MARKET, SideEnum.BUY, marketBuyMatchService);</span><br><span class="line">        MatchStrategy.register(OrderTypeEnum.MARKET, SideEnum.SELL, marketSellMatchService);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangeCore</span> <span class="keyword">extends</span> <span class="title class_">AbstractLifeCycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Disruptor&lt;DisruptorEvent&gt; disruptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MatchEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResultsHandler eventHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExchangeCore</span><span class="params">(ResultsHandler matchHandler, <span class="type">int</span> ringBufferSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="type">EventFactory</span> <span class="variable">eventFactory</span> <span class="operator">=</span> () -&gt; <span class="keyword">new</span> <span class="title class_">DisruptorEvent</span>();</span><br><span class="line">        <span class="built_in">this</span>.disruptor = <span class="keyword">new</span> <span class="title class_">Disruptor</span>&lt;&gt;(eventFactory, ringBufferSize, threadFactory);</span><br><span class="line">        publisher = <span class="keyword">new</span> <span class="title class_">MatchEventPublisher</span>(<span class="built_in">this</span>.disruptor);</span><br><span class="line">        disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> <span class="title class_">DisruptorExceptionHandler</span>());</span><br><span class="line">        <span class="built_in">this</span>.eventHandler = matchHandler;</span><br><span class="line">        disruptor.handleEventsWith(eventHandler);</span><br><span class="line">        disruptor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.stop();</span><br><span class="line">        disruptor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BaseResponse <span class="title function_">doMatch</span><span class="params">(EntrustOrder taker)</span> &#123;</span><br><span class="line">        <span class="comment">// 前置处理----start</span></span><br><span class="line">        <span class="keyword">if</span> (OrderTypeEnum.getOrderTypeEnum(taker.getOrderType()) == <span class="literal">null</span> || SideEnum.getSideEnum(taker.getSide()) == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125; - parameter error:&#123;&#125; or &#123;&#125;&quot;</span>, taker.getTraceId(), <span class="string">&quot;orderType&quot;</span>, <span class="string">&quot;side&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> BaseResponse.error(TradingMatchCodeEnum.PARAMETER_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">MatchStatusEnum</span> <span class="variable">matchStatusEnum</span> <span class="operator">=</span> OrderBook.getByOrderId(taker.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="type">MetricService</span> <span class="variable">metricService</span> <span class="operator">=</span> SpringContextUtil.getBean(MetricService.class);</span><br><span class="line">        <span class="type">MatchClusterConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> SpringContextUtil.getBean(MatchClusterConfiguration.class);</span><br><span class="line">        <span class="comment">// 撮合防重校验，并发存在问题。但是消费的时候，是单线程，做了校验，不存在重复撮合的问题。</span></span><br><span class="line">        <span class="keyword">if</span> (OperationTypeEnum.MATCH.getCode() == taker.getOperationType()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchStatusEnum != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//短时间内重复撮合</span></span><br><span class="line">                log.error(<span class="string">&quot;&#123;&#125; - match repeat ,orderId :&#123;&#125;&quot;</span>, taker.getTraceId(), taker.getOrderId());</span><br><span class="line">                <span class="keyword">return</span> BaseResponse.error(TradingMatchCodeEnum.REPEAT_REQUEST);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//构造对象进入等待队列</span></span><br><span class="line">            OrderBook.addToOrderBook(taker.getOrderId(), MatchStatusEnum.WAIT_ING);</span><br><span class="line">            metricService.count(MetricNames.ORDER_TYPE_NUM, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;match&quot;</span>, <span class="string">&quot;group&quot;</span>, configuration.getClusterName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OperationTypeEnum.CANCEL.getCode() == taker.getOperationType()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cancelType</span> <span class="operator">=</span> taker.getCancelType();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             异常单-产生情况：收单服务 调用撮合 出现异常，不知道成功没，没有明确响应 开始进行异常撤单</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (CancelTypeEnum.NORMAL_CANCEL.getCode() == cancelType) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matchStatusEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 数据有可能在请求队列中被逐出，需要继续走逻辑</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (MatchStatusEnum.MATCH_END == matchStatusEnum) &#123;</span><br><span class="line">                        <span class="comment">//重复撤销，深度盘已经没有数据，没必要继续往下,不走disruptor 和撮合直接返回</span></span><br><span class="line">                        log.error(<span class="string">&quot;&#123;&#125; - cancel failed, match end ,orderId :&#123;&#125;&quot;</span>, taker.getTraceId(), taker.getOrderId());</span><br><span class="line">                        <span class="keyword">return</span> BaseResponse.error(TradingMatchCodeEnum.REPEAT_REQUEST);</span><br><span class="line">                    &#125;</span><br><span class="line">                    OrderBook.addToOrderBook(taker.getOrderId(), MatchStatusEnum.WAIT_CANCEL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// reload异常撤单，要加入内存</span></span><br><span class="line">                OrderBook.addToOrderBook(taker.getOrderId(), MatchStatusEnum.WAIT_CANCEL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;--------can not find the operationType[&#123;&#125;]&quot;</span>, taker.getOperationType());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TradingMatchException</span>(<span class="string">&quot;can not find the operationType[&quot;</span> + taker.getOperationType() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前置处理----end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Disruptor开始发布事件</span></span><br><span class="line">        publisher.publish(taker);</span><br><span class="line">        <span class="keyword">return</span> BaseResponse.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Disruptor&lt;DisruptorEvent&gt; <span class="title function_">getDisruptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> disruptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatchEventPublisher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Disruptor&lt;DisruptorEvent&gt; disruptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatchEventPublisher</span><span class="params">(Disruptor&lt;DisruptorEvent&gt; disruptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.disruptor = disruptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventTranslatorOneArg&lt;DisruptorEvent, EntrustOrder&gt; TRANSLATOR =</span><br><span class="line">            (event, sequence, entrustOrder) -&gt; &#123;</span><br><span class="line">                event.setEntrustOrder(entrustOrder);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(EntrustOrder taker)</span> &#123;</span><br><span class="line">        RingBuffer&lt;DisruptorEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        taker.setSequence(ringBuffer.getCursor());</span><br><span class="line">        taker.setArriveTime(System.currentTimeMillis());</span><br><span class="line">        ringBuffer.publishEvent(TRANSLATOR, taker);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五</strong></p>
<p><strong>总结</strong></p>
<p>Disruptor作为一个以高性能著称的队列，它有很多优秀的设计思想值得我们学习，比如环形数组队列RingBuffer、SequenceBarrier机制、无锁化设计、预分配内存、消除伪共享、以及灵活丰富的生产者和消费者模式。本文只是介绍了一些对Disruptor的基本功能和实际使用场景，后续大家有兴趣可以结合源码去做更加深入的理解。由于本人文笔和经验有限，若有不足之处，还请及时指正，共同学习和进步。</p>
<p><strong>引用：</strong></p>
<p><a target="_blank" rel="noopener" href="https://lmax-exchange.github.io/disruptor/user-guide/#_advanced_techniques">https://lmax-exchange.github.io/disruptor/user-guide/#_advanced_techniques</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/Disruptor%E5%9C%A8%E6%92%AE%E5%90%88%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BD%9C%E5%BE%97%E7%89%A9%E6%8A%80%E6%9C%AF/" data-id="cm42pghe20001ogslenzu03ai" data-title="Disruptor在撮合引擎的实践｜得物技术" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-设置元素居中的7种办法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%847%E7%A7%8D%E5%8A%9E%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T00:29:36.000Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/08/%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%847%E7%A7%8D%E5%8A%9E%E6%B3%95/">设置元素居中的7种办法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>方法一：使用 flex布局 1</p>
<p>HTML 结构如下：父元素 outer 子元素 inner</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>css 样式：</p>
<p>父元素设置为 flex布局 加入以下代码,实现子元素自动居中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>


<p>完整 css 代码如下: </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="comment">/* 方案一：设置水平、垂直居中 */</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二：使用 flex布局 2</p>
<p>还是上面的结构，但是父元素的下面这两行代码去掉:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">justify-content</span>: center;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br></pre></td></tr></table></figure>


<p>去掉后在子元素加入</p>
<p>margin: auto;<br> 完整 css 代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="comment">/* 方案二: 父元素设置flex布局 子元素 */</span></span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>方法三：使用 grid 布局 </p>
<p>父元素设置 grid 布局，设置水平垂直居中</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: grid;</span><br><span class="line">place-items: center;</span><br></pre></td></tr></table></figure>


<p>完整 css 代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#888</span>;</span><br><span class="line">    <span class="comment">/* 设置grid布局 */</span></span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    place-items: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p> 方法四：一些大总结</p>
<p>1.水平居中：</p>
<p>如果子元素为块级元素 如 div 父元素设置以下代码可以水平居中</p>
<p>margin: 0 auto;<br>对于内联元素（如 span或 a）或行内块元素，需要水平居中可以使用 </p>
<p>text-align: center;<br>2.垂直居中：</p>
<p>若子元素为块元素，给子元素加上</p>
<p>margin-top: (父元素高-子元素总高) &#x2F; 2<br>若子元素为行内元素、行内块元素 需要设置行高为子元素的高度</p>
<p>line-height &#x3D; height;<br>&#x2F;<em>注意height为子元素的总高</em>&#x2F;<br>每个子元素加上</p>
<p>vertical-align: middle;<br>若想要绝对垂直居中则在父元素加上，同时这行代码还可以消除 HTML 结构换行带来的空格，但注意子元素的字体大小需要重新设置</p>
<p>font-size: 0px;<br>方法五：借助定位 1</p>
<p>子元素设置 绝对定位 父元素设置 相对定位</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="comment">/* 块级元素包含块级元素，可以使用定位水平、垂直居中 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="comment">/* 方案一 更推荐*/</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>方法六：借助定位 2</p>
<p>子元素设置定位，然后手动计算需要移动的距离 </p>
<p>margin-top：-元素高度&#x2F;2 px;</p>
<p>margin-left：-元素宽度&#x2F;2 px;</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="comment">/* 块级元素包含块级元素，可以使用定位水平、垂直居中 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="comment">/* 方案二 */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法七：借助定位 + 2D变换—移动</p>
<p>这种方式比方法五好一些，不需要计算具体要移动多少像素</p>
<p>transform: translate(-50%,-50%);<br>完整 css 代码如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line">    <span class="comment">/* 块级元素包含块级元素，可以使用定位水平、垂直居中 */</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="comment">/* 方案三 */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%847%E7%A7%8D%E5%8A%9E%E6%B3%95/" data-id="cm42pghea0008ogsl8b4j32mt" data-title="设置元素居中的7种办法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-从 synchronized 到 CAS 和 AQS - 彻底弄懂 Java 各种并发锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/07/%E4%BB%8E%20synchronized%20%E5%88%B0%20CAS%20%E5%92%8C%20AQS%20-%20%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Java%20%E5%90%84%E7%A7%8D%E5%B9%B6%E5%8F%91%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2024-10-07T05:29:14.000Z" itemprop="datePublished">2024-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/07/%E4%BB%8E%20synchronized%20%E5%88%B0%20CAS%20%E5%92%8C%20AQS%20-%20%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Java%20%E5%90%84%E7%A7%8D%E5%B9%B6%E5%8F%91%E9%94%81/">从 synchronized 到 CAS 和 AQS - 彻底弄懂 Java 各种并发锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 中的并发锁大致分为隐式锁和显式锁两种。隐式锁就是我们最常使用的 <code>synchronized</code> 关键字，显式锁主要包含两个接口：<code>Lock</code> 和 <code>ReadWriteLock</code>，主要实现类分别为 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code>，这两个类都是基于 AQS(<code>AbstractQueuedSynchronizer</code>) 实现的。还有的地方将 CAS 也称为一种锁，在包括 AQS 在内的很多并发相关类中，CAS 都扮演了很重要的角色。</p>
<p>我们只需要弄清楚 synchronized 和 AQS 的原理，再去理解并发锁的性质和局限就很简单了。因此这篇文章重点放在原理上，对于使用和特点不会过多涉及。</p>
<h1 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h1><p>下面是关于锁的一些概念解释，这些都是一些关于锁的性质的描述，并非具体实现。</p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>悲观锁和独占锁是一个意思，它假设一定会发生冲突，因此获取到锁之后会阻塞其他等待线程。这么做的好处是简单安全，但是挂起线程和恢复线程都需要转入内核态进行，这样做会带来很大的性能开销。悲观锁的代表是 synchronized。然而在真实环境中，大部分时候都不会产生冲突。悲观锁会造成很大的浪费。而乐观锁不一样，它假设不会产生冲突，先去尝试执行某项操作，失败了再进行其他处理（一般都是不断循环重试）。这种锁不会阻塞其他的线程，也不涉及上下文切换，性能开销小。代表实现是 CAS。</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁是指各个线程在加锁前先检查有无排队的线程，按排队顺序去获得锁。 非公平锁是指线程加锁前不考虑排队问题，直接尝试获取锁，获取不到再去队尾排队。值得注意的是，在 AQS 的实现中，一旦线程进入排队队列，即使是非公平锁，线程也得乖乖排队。</p>
<h2 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h2><p>如果一个线程已经获取到了一个锁，那么它可以访问被这个锁锁住的所有代码块。不可重入锁与之相反。</p>
<h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><p>Synchronized 是一种独占锁。在修饰静态方法时，锁的是类对象，如 Object.class。修饰非静态方法时，锁的是对象，即 this。修饰方法块时，锁的是括号里的对象。 每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性。</p>
<h2 id="类锁与对象锁"><a href="#类锁与对象锁" class="headerlink" title="类锁与对象锁"></a>类锁与对象锁</h2><p>synchronized 修饰静态方法时，锁的是类对象,如 Object.class。修饰非静态方法时，锁的是对象，即 this。 多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的。</p>
<p>synchronized 锁住的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。</p>
<p>此外，需要说明的，synchronized方法不能防止非synchronized方法被同时执行，所以，一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>synchronized 是基于 Java 对象头和 Monitor 机制来实现的。</p>
<h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>一个对象在内存中包含三部分：对象头，实例数据和对齐填充。其中 Java 对象头包含两部分：</p>
<ul>
<li>Class Metadata Address （类型指针）。存储类的元数据的指针。虚拟机通过这个指针找到它是哪个类的实例。</li>
<li>Mark Word（标记字段）。存出一些对象自身运行时的数据。包括哈希码，GC 分代年龄，锁状态标志等。</li>
</ul>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。 monitor 对象由 C++ 实现。其中有三个关键字段：</p>
<ul>
<li>_owner 记录当前持有锁的线程</li>
<li>_EntryList 是一个队列，记录所有阻塞等待锁的线程</li>
<li>_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程。</li>
</ul>
<p>Monitor的操作机制如下：</p>
<ol>
<li>多个线程竞争锁时，会先进入 EntryList 队列。竞争成功的线程被标记为 Owner。其他线程继续在此队列中阻塞等待。</li>
<li>如果 Owner 线程调用 wait() 方法，则其释放对象锁并进入 WaitSet 中等待被唤醒。Owner 被置空，EntryList 中的线程再次竞争锁。</li>
<li>如果 Owner 线程执行完了，便会释放锁，Owner 被置空，EntryList 中的线程再次竞争锁。</li>
</ol>
<h3 id="JVM-对-synchronized-的处理"><a href="#JVM-对-synchronized-的处理" class="headerlink" title="JVM 对 synchronized 的处理"></a>JVM 对 synchronized 的处理</h3><p>上面了解了 monitor 的机制，那虚拟机是如何将 synchronized 和 monitor 关联起来的呢？分两种情况：</p>
<ul>
<li>如果同步的是代码块，编译时会直接在同步代码块前加上 monitorenter 指令，代码块后加上 monitorexit 指令。这称为显示同步。</li>
<li>如果同步的是方法，虚拟机会为方法设置 ACC_SYNCHRONIZED 标志。调用的时候 JVM 根据这个标志判断是否是同步方法。</li>
</ul>
<h2 id="JVM-对-synchronized-的优化"><a href="#JVM-对-synchronized-的优化" class="headerlink" title="JVM 对 synchronized 的优化"></a>JVM 对 synchronized 的优化</h2><p>synchronized 是重量级锁，由于消耗太大，虚拟机对其做了一些优化。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>在许多应用中，锁定状态只会持续很短的时间，为了这么一点时间去挂起恢复线程，不值得。我们可以让等待线程执行一定次数的循环，在循环中去获取锁。这项技术称为自旋锁，它可以节省系统切换线程的消耗，但仍然要占用处理器。在 JDK1.4.2 中，自选的次数可以通过参数来控制。 JDK 1.6又引入了自适应的自旋锁，不再通过次数来限制，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>虚拟机在运行时，如果发现一段被锁住的代码中不可能存在共享数据，就会将这个锁清除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>当虚拟机检测到有一串零碎的操作都对同一个对象加锁时，会把锁扩展到整个操作序列外部。如 StringBuffer 的 append 操作。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>对绝大部分的锁来说，在整个同步周期内都不存在竞争。如果没有竞争，轻量级锁可以使用 CAS 操作避免使用互斥量的开销。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="操作模型"><a href="#操作模型" class="headerlink" title="操作模型"></a>操作模型</h2><p>CAS 是 compare and swap 的简写，即比较并交换。它是指一种操作机制，而不是某个具体的类或方法。在 Java 平台上对这种操作进行了包装。在 Unsafe 类中，调用代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br></pre></td></tr></table></figure>

<p>它需要三个参数，分别是内存位置 V，旧的预期值 A 和新的值 B。操作时，先从内存位置读取到值，然后和预期值A比较。如果相等，则将此内存位置的值改为新值 B，返回 true。如果不相等，说明和其他线程冲突了，则不做任何改变，返回 false。</p>
<p>这种机制在不阻塞其他线程的情况下避免了并发冲突，比独占锁的性能高很多。 CAS 在 Java 的原子类和并发包中有大量使用。</p>
<h2 id="重试机制（循环-CAS）"><a href="#重试机制（循环-CAS）" class="headerlink" title="重试机制（循环 CAS）"></a>重试机制（循环 CAS）</h2><p><strong>有很多文章说，CAS 操作失败后会一直重试直到成功，这种说法很不严谨。</strong></p>
<p>第一，CAS 本身并未实现失败后的处理机制，它只负责返回成功或失败的布尔值，后续由调用者自行处理。只不过我们最常用的处理方式是重试而已。</p>
<p>第二，这句话很容易理解错，被理解成重新比较并交换。实际上失败的时候，原值已经被修改，如果不更改期望值，再怎么比较都会失败。而新值同样需要修改。</p>
<p>所以正确的方法是，使用一个死循环进行 CAS 操作，成功了就结束循环返回，失败了就重新从内存读取值和计算新值，再调用 CAS。看下 AtomicInteger 的源码就什么都懂了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>CAS 主要分三步，读取-比较-修改。其中比较是在检测是否有冲突，如果检测到没有冲突后，其他线程还能修改这个值，那么 CAS 还是无法保证正确性。所以最关键的是要保证比较-修改这两步操作的原子性。</p>
<p>CAS 底层是靠调用 CPU 指令集的 cmpxchg 完成的，它是 x86 和 Intel 架构中的 compare and exchange 指令。在多核的情况下，这个指令也不能保证原子性，需要在前面加上 lock 指令。lock 指令可以保证一个 CPU 核心在操作期间独占一片内存区域。那么 这又是如何实现的呢？</p>
<p>在处理器中，一般有两种方式来实现上述效果：总线锁和缓存锁。在多核处理器的结构中，CPU 核心并不能直接访问内存，而是统一通过一条总线访问。总线锁就是锁住这条总线，使其他核心无法访问内存。这种方式代价太大了，会导致其他核心停止工作。而缓存锁并不锁定总线，只是锁定某部分内存区域。当一个 CPU 核心将内存区域的数据读取到自己的缓存区后，它会锁定缓存对应的内存区域。锁住期间，其他核心无法操作这块内存区域。</p>
<p>CAS 就是通过这种方式实现比较和交换操作的原子性的。<strong>值得注意的是， CAS 只是保证了操作的原子性，并不保证变量的可见性，因此变量需要加上 volatile 关键字。</strong></p>
<h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><p>上面提到，CAS 保证了比较和交换的原子性。但是从读取到开始比较这段期间，其他核心仍然是可以修改这个值的。如果核心将 A 修改为 B，CAS 可以判断出来。但是如果核心将 A 修改为 B 再修改回 A。那么 CAS 会认为这个值并没有被改变，从而继续操作。这是和实际情况不符的。解决方案是加一个版本号。</p>
<h1 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁 ReentrantLock"></a>可重入锁 ReentrantLock</h1><p>ReentrantLock 使用代码实现了和 synchronized 一样的语义，包括可重入，保证内存可见性和解决竞态条件问题等。相比 synchronized，它还有如下好处：</p>
<ul>
<li>支持以非阻塞方式获取锁</li>
<li>可以响应中断</li>
<li>可以限时</li>
<li>支持了公平锁和非公平锁</li>
</ul>
<p>基本用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 内部有两个内部类，分别是 FairSync 和 NoFairSync，对应公平锁和非公平锁。他们都继承自 Sync。Sync 又继承自AQS。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 全称 <code>AbstractQueuedSynchronizer</code>。AQS 中有两个重要的成员：</p>
<ul>
<li>成员变量 state。用于表示锁现在的状态，用 volatile 修饰，保证内存一致性。同时所用对 state 的操作都是使用 CAS 进行的。state 为0表示没有任何线程持有这个锁，线程持有该锁后将 state 加1，释放时减1。多次持有释放则多次加减。</li>
<li>还有一个双向链表，链表除了头结点外，每一个节点都记录了线程的信息，代表一个等待线程。这是一个 FIFO 的链表。</li>
</ul>
<p>下面以 ReentrantLock 非公平锁的代码看看 AQS 的原理。</p>
<h2 id="请求锁"><a href="#请求锁" class="headerlink" title="请求锁"></a>请求锁</h2><p>请求锁时有三种可能：</p>
<ol>
<li>如果没有线程持有锁，则请求成功，当前线程直接获取到锁。</li>
<li>如果当前线程已经持有锁，则使用 CAS 将 state 值加1，表示自己再次申请了锁，释放锁时减1。这就是可重入性的实现。</li>
<li>如果由其他线程持有锁，那么将自己添加进等待队列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))   </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread()); <span class="comment">//没有线程持有锁时，直接获取锁，对应情况1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">//在此方法中会判断当前持有线程是否等于自己，对应情况2</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//将自己加入队列中，对应情况3</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建-Node-节点并加入链表"><a href="#创建-Node-节点并加入链表" class="headerlink" title="创建 Node 节点并加入链表"></a>创建 Node 节点并加入链表</h2><p>如果没竞争到锁，这时候就要进入等待队列。队列是默认有一个 head 节点的，并且不包含线程信息。上面情况3中，addWaiter 会创建一个 Node，并添加到链表的末尾，Node 中持有当前线程的引用。同时还有一个成员变量 waitStatus，表示线程的等待状态，初始值为0。我们还需要关注两个值：</p>
<ul>
<li>CANCELLED，值为1，表示取消状态，就是说我不要这个锁了，请你把我移出去。</li>
<li>SINGAL，值为-1，表示下一个节点正在挂起等待，注意是下一个节点，不是当前节点。</li>
</ul>
<p>同时，加到链表末尾的操作使用了 CAS+死循环的模式，很有代表性，拿出来看一看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(mode);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">oldTail</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (oldTail != <span class="literal">null</span>) &#123;</span><br><span class="line">        U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">            oldTail.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initializeSyncQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在死循环里调用了 CAS 的方法。如果多个线程同时调用该方法，那么每次循环都只有一个线程执行成功，其他线程进入下一次循环，重新调用。N个线程就会循环N次。这样就在无锁的模式下实现了并发模型。</p>
<h2 id="挂起等待"><a href="#挂起等待" class="headerlink" title="挂起等待"></a>挂起等待</h2><ul>
<li>如果此节点的上一个节点是头部节点，则再次尝试获取锁，获取到了就移除并返回。获取不到就进入下一步；</li>
<li>判断前一个节点的 waitStatus，如果是 SINGAL，则返回 true，并调用 LockSupport.park() 将线程挂起；</li>
<li>如果是 CANCELLED，则将前一个节点移除；</li>
<li>如果是其他值，则将前一个节点的 waitStatus 标记为 SINGAL，进入下一次循环。</li>
</ul>
<p>可以看到，一个线程最多有两次机会，还竞争不到就去挂起等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><ul>
<li>调用 tryRelease，此方法由子类实现。实现非常简单，如果当前线程是持有锁的线程，就将 state 减1。减完后如果 state 大于0，表示当前线程仍然持有锁，返回 false。如果等于0，表示已经没有线程持有锁，返回 true，进入下一步；</li>
<li>如果头部节点的 waitStatus 不等于0，则调用LockSupport.unpark()唤醒其下一个节点。头部节点的下一个节点就是等待队列中的第一个线程，这反映了 AQS 先进先出的特点。另外，即使是非公平锁，进入队列之后，还是得按顺序来。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123; //将 state 减1</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        node.compareAndSetWaitStatus(ws, 0);</span><br><span class="line">        </span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123; </span><br><span class="line">        s = null;</span><br><span class="line">        for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span><br><span class="line">            if (p.waitStatus &lt;= 0)</span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null) //唤醒第一个等待的线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="公平锁如何实现"><a href="#公平锁如何实现" class="headerlink" title="公平锁如何实现"></a>公平锁如何实现</h2><p>上面分析的是非公平锁，那公平锁呢？很简单，在竞争锁之前判断一下等待队列中有没有线程在等待就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//判断等待队列是否有节点</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可重入读写锁-ReentrantReadWriteLock"><a href="#可重入读写锁-ReentrantReadWriteLock" class="headerlink" title="可重入读写锁 ReentrantReadWriteLock"></a>可重入读写锁 ReentrantReadWriteLock</h1><h2 id="读写锁机制"><a href="#读写锁机制" class="headerlink" title="读写锁机制"></a>读写锁机制</h2><p>理解 ReentrantLock 和 AQS 之后，再来理解读写锁就很简单了。读写锁有一个读锁和一个写锁，分别对应读操作和锁操作。锁的特性如下：</p>
<ul>
<li>只有一个线程可以获取到写锁。在获取写锁时，只有没有任何线程持有任何锁才能获取成功；</li>
<li>如果有线程正持有写锁，其他任何线程都获取不到任何锁；</li>
<li>没有线程持有写锁时，可以有多个线程获取到读锁。</li>
</ul>
<p>上面锁的特点保证了可以并发读取，这大大提高了效率，在实际开发中非常有用。那么在具体是如何实现的呢？</p>
<h2 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h2><p>读写锁虽然有两个锁，但实际上只有一个等待队列。</p>
<ul>
<li>获取写锁时，要保证没有任何线程持有锁；</li>
<li>写锁释放后，会唤醒队列第一个线程，可能是读锁和写锁；</li>
<li>获取读锁时，先判断写锁有没有被持有，没有就可以获取成功；</li>
<li>获取读锁成功后，会将队列中等待读锁的线程挨个唤醒，知道遇到等待写锁的线程位置；</li>
<li>释放读锁时，要检查读锁数，如果为0，则唤醒队列中的下一个线程，否则不进行操作。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000014858404">Java CAS 原理分析</a></p>
<p><a href="https://link.juejin.cn/?target=http://www.importnew.com/24006.html">扒一扒ReentrantLock以及AQS实现原理</a></p>
<p><a href="https://link.juejin.cn/?target=https://blog.csdn.net/javazejian/article/details/72828483">深入理解Java并发之synchronized实现原理</a></p>
<p><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzIxOTI1NTk5Nw==&mid=2650047459&idx=1&sn=8213beaa3fdcbfcdc2639d000933c5ff&chksm=8fde2631b8a9af272788163860719bcee6c82859b6c31c215042b143cb67f05d6b038fb67938&scene=21%23wechat_redirect">显式锁 &#x2F; 计算机程序的思维逻辑</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/07/%E4%BB%8E%20synchronized%20%E5%88%B0%20CAS%20%E5%92%8C%20AQS%20-%20%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Java%20%E5%90%84%E7%A7%8D%E5%B9%B6%E5%8F%91%E9%94%81/" data-id="cm42pghe70004ogsl9zl1g57i" data-title="从 synchronized 到 CAS 和 AQS - 彻底弄懂 Java 各种并发锁" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-策略+工厂模式解决if-else" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/07/%E7%AD%96%E7%95%A5+%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3if-else/" class="article-date">
  <time class="dt-published" datetime="2024-10-07T02:07:35.000Z" itemprop="datePublished">2024-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/07/%E7%AD%96%E7%95%A5+%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3if-else/">策略+工厂模式解决if-else</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>假设我们要做一个外卖平台，有这样的需求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、外卖平台上的某家店铺为了促销，设置了多种会员优惠，其中包含**超级会员**折扣8折、**普通会员**折扣9折、**普通用户**没有折扣三种。</span><br><span class="line"></span><br><span class="line">2、希望用户在付款的时候，根据用户的会员等级，就可以知道用户符合哪种折扣策略，进而进行打折，计算出应付金额。</span><br><span class="line"></span><br><span class="line">3、随着业务发展，新的需求要求**专属会员**要在店铺下单金额大于30元的时候才可以享受优惠。</span><br><span class="line"></span><br><span class="line">4、接着，又有一个变态的需求，如果用户的超级会员已经到期了，并且到期时间在一周内，那么就对用户的单笔订单按照超级会员进行折扣，并在收银台进行强提醒，引导用户再次开通会员，而且折扣只进行一次。</span><br></pre></td></tr></table></figure>

<p>那么，我们可以看到以下伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">calPrice</span><span class="params">(BigDecimal orderPrice, String buyerType)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (用户是专属会员) &#123;</span><br><span class="line">        <span class="keyword">if</span> (订单金额大于<span class="number">30</span>元) &#123;</span><br><span class="line">            returen <span class="number">7</span>折价格;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (用户是超级会员) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>折价格;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (用户是普通会员) &#123;</span><br><span class="line">        <span class="keyword">if</span>(该用户超级会员刚过期并且尚未使用过临时折扣)&#123;</span><br><span class="line">            临时折扣使用次数更新();</span><br><span class="line">            returen <span class="number">8</span>折价格;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>折价格;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 原价;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就是对于这个需求的一段价格计算逻辑，使用伪代码都这么复杂，如果是真的写代码，那复杂度可想而知。</p>
<p>这样的代码中，有很多if-else，并且还有很多的if-else的嵌套，无论是可读性还是可维护性都非常低。</p>
<p>那么，如何改善呢？</p>
<p>策略模式</p>
<p>接下来，我们尝试引入策略模式来提升代码的可维护性和可读性。</p>
<p>首先，定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserPayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算应付价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接着定义几个策略类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParticularlyVipPayService</span> <span class="keyword">implements</span> <span class="title class_">UserPayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (消费金额大于<span class="number">30</span>元) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">7</span>折价格;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperVipPayService</span> <span class="keyword">implements</span> <span class="title class_">UserPayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>折价格;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipPayService</span> <span class="keyword">implements</span> <span class="title class_">UserPayService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(该用户超级会员刚过期并且尚未使用过临时折扣)&#123;</span><br><span class="line">            临时折扣使用次数更新();</span><br><span class="line">            returen <span class="number">8</span>折价格;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>折价格;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>引入了策略之后，我们可以按照如下方式进行价格计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserPayService</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VipPayService</span>();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">quote</span> <span class="operator">=</span> strategy.quote(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通会员商品的最终价格为：&quot;</span> + quote.doubleValue());</span><br><span class="line"></span><br><span class="line">        strategy = <span class="keyword">new</span> <span class="title class_">SuperVipPayService</span>();</span><br><span class="line">        quote = strategy.quote(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;超级会员商品的最终价格为：&quot;</span> + quote.doubleValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上，就是一个例子，可以在代码中new出不同的会员的策略类，然后执行对应的计算价格的方法。这个例子以及策略模式的相关知识，读者可以在《<a href="https://link.juejin.cn/?target=http://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247485532&idx=1&sn=d915794a429ca24875eb6343d9322787&chksm=cef5fbeaf98272fcfb80075078b4419ee7f9d703eee5aa79c2b50a31248ed2905748224ce1a9&scene=21%23wechat_redirect"><strong>如何给女朋友解释什么是策略模式？</strong></a>》一文中学习。</p>
<p>但是，真正在代码中使用，比如在一个web项目中使用，上面这个Demo根本没办法直接用。</p>
<p>首先，在web项目中，上面我们创建出来的这些策略类都是被Spring托管的，我们不会自己去new一个实例出来。</p>
<p>其次，在web项目中，如果真要计算价格，也是要事先知道用户的会员等级，比如从数据库中查出会员等级，然后根据等级获取不同的策略类执行计算价格方法。</p>
<p>那么，web项目中真正的计算价格的话，伪代码应该是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal calPrice(BigDecimal orderPrice,User user) &#123;</span><br><span class="line"></span><br><span class="line">     String vipType = user.getVipType();</span><br><span class="line"></span><br><span class="line">     if (vipType == 专属会员) &#123;</span><br><span class="line">        //伪代码：从Spring中获取超级会员的策略对象</span><br><span class="line">        UserPayService strategy = Spring.getBean(ParticularlyVipPayService.class);</span><br><span class="line">        return strategy.quote(orderPrice);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (vipType == 超级会员) &#123;</span><br><span class="line">        UserPayService strategy = Spring.getBean(SuperVipPayService.class);</span><br><span class="line">        return strategy.quote(orderPrice);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (vipType == 普通会员) &#123;</span><br><span class="line">        UserPayService strategy = Spring.getBean(VipPayService.class);</span><br><span class="line">        return strategy.quote(orderPrice);</span><br><span class="line">     &#125;</span><br><span class="line">     return 原价;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过以上代码，我们发现，代码可维护性和可读性好像是好了一些，但是好像并没有减少if-else啊。</p>
<p>其实，在之前的《<a href="https://link.juejin.cn/?target=http://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247485532&idx=1&sn=d915794a429ca24875eb6343d9322787&chksm=cef5fbeaf98272fcfb80075078b4419ee7f9d703eee5aa79c2b50a31248ed2905748224ce1a9&scene=21%23wechat_redirect"><strong>如何给女朋友解释什么是策略模式？</strong></a>》一文中，我们介绍了很多策略模式的优点。但是，策略模式的使用上，还是有一个比较大的缺点的：</p>
<blockquote>
<p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。</p>
</blockquote>
<p>也就是说，虽然在计算价格的时候没有if-else了，但是选择具体的策略的时候还是不可避免的还是要有一些if-else。</p>
<p>另外，上面的伪代码中，从Spring中获取会员的策略对象我们是伪代码实现的，那么代码到底该如何获取对应的Bean呢？</p>
<p>接下来我们看如何借助Spring和工厂模式，解决上面这些问题。</p>
<p>工厂模式</p>
<p>为了方便我们从Spring中获取UserPayService的各个策略类，我们创建一个工厂类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserPayServiceStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,UserPayService&gt; services = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String,UserPayService&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> UserPayService <span class="title function_">getByUserType</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> services.get(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String userType,UserPayService userPayService)</span>&#123;</span><br><span class="line">        Assert.notNull(userType,<span class="string">&quot;userType can&#x27;t be null&quot;</span>);</span><br><span class="line">        services.put(userType,userPayService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个<code>UserPayServiceStrategyFactory</code>中定义了一个Map，用来保存所有的策略类的实例，并提供一个<code>getByUserType</code>方法，可以根据类型直接获取对应的类的实例。还有一个register方法，这个后面再讲。</p>
<p>有了这个工厂类之后，计算价格的代码即可得到大大的优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">calPrice</span><span class="params">(BigDecimal orderPrice,User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">String</span> <span class="variable">vipType</span> <span class="operator">=</span> user.getVipType();</span><br><span class="line">     <span class="type">UserPayService</span> <span class="variable">strategy</span> <span class="operator">=</span> UserPayServiceStrategyFactory.getByUserType(vipType);</span><br><span class="line">     <span class="keyword">return</span> strategy.quote(orderPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码中，不再需要if-else了，拿到用户的vip类型之后，直接通过工厂的getByUserType方法直接调用就可以了。</p>
<p>通过策略+工厂，我们的代码很大程度的优化了，大大提升了可读性和可维护性。</p>
<p>但是，上面还遗留了一个问题，那就是UserPayServiceStrategyFactory中用来保存所有的策略类的实例的Map是如何被初始化的？各个策略的实例对象如何塞进去的呢？</p>
<p>Spring Bean的注册</p>
<p>还记得我们前面定义的UserPayServiceStrategyFactory中提供了的register方法吗？他就是用来注册策略服务的。</p>
<p>接下来，我们就想办法调用register方法，把Spring通过IOC创建出来的Bean注册进去就行了。</p>
<p>这种需求，可以借用Spring种提供的InitializingBean接口，这个接口为Bean提供了属性初始化后的处理方法，它只包括afterPropertiesSet方法，凡是继承该接口的类，在bean的属性初始化后都会执行该方法。</p>
<p>那么，我们将前面的各个策略类稍作改造即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParticularlyVipPayService</span> <span class="keyword">implements</span> <span class="title class_">UserPayService</span>,InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (消费金额大于<span class="number">30</span>元) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">7</span>折价格;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserPayServiceStrategyFactory.register(<span class="string">&quot;ParticularlyVip&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperVipPayService</span> <span class="keyword">implements</span> <span class="title class_">UserPayService</span> ,InitializingBean&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>折价格;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserPayServiceStrategyFactory.register(<span class="string">&quot;SuperVip&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipPayService</span> <span class="keyword">implements</span> <span class="title class_">UserPayService</span>,InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">quote</span><span class="params">(BigDecimal orderPrice)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(该用户超级会员刚过期并且尚未使用过临时折扣)&#123;</span><br><span class="line">            临时折扣使用次数更新();</span><br><span class="line">            returen <span class="number">8</span>折价格;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>折价格;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserPayServiceStrategyFactory.register(<span class="string">&quot;Vip&quot;</span>,<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>只需要每一个策略服务的实现类都实现InitializingBean接口，并实现其afterPropertiesSet方法，在这个方法中调用UserPayServiceStrategyFactory.register即可。</p>
<p>这样，在Spring初始化的时候，当创建VipPayService、SuperVipPayService和ParticularlyVipPayService的时候，会在Bean的属性初始化之后，把这个Bean注册到UserPayServiceStrategyFactory中。</p>
<p>以上代码，其实还是有一些重复代码的，这里面还可以引入模板方法模式进一步精简，这里就不展开了。</p>
<p>还有就是，<code>UserPayServiceStrategyFactory.register()</code>调用的时候，第一个参数需要传一个字符串，这里的话其实也可以优化掉。比如使用枚举，或者在每个策略类中自定义一个<code>getUserType</code>方法，各自实现即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文，我们通过策略模式、工厂模式以及Spring的InitializingBean，提升了代码的可读性以及可维护性，彻底消灭了一坨if-else。</p>
<p>文中的这种做法，大家可以立刻尝试起来，这种实践，是我们日常开发中经常用到的，而且还有很多衍生的用法，也都非常好用。有机会后面再介绍。</p>
<p>其实，如果读者们对策略模式和工厂模式了解的话，文中使用的并不是严格意义上面的策略模式和工厂模式。</p>
<p>首先，策略模式中重要的Context角色在这里面是没有的，没有Context，也就没有用到组合的方式，而是使用工厂代替了。</p>
<p>另外，这里面的UserPayServiceStrategyFactory其实只是维护了一个Map，并提供了register和get方法而已，而工厂模式其实是帮忙创建对象的，这里并没有用到。</p>
<p>所以，读者不必纠结于到底是不是真的用了策略模式和工厂模式。而且，这里面也再扩展一句，所谓的GOF 23种设计模式，无论从哪本书或者哪个博客看，都是简单的代码示例，但是我们日常开发很多都是基于Spring等框架的，根本没办法直接用的。</p>
<p>所以，对于设计模式的学习，重要的是学习其思想，而不是代码实现！！！</p>
<p>如果读者们感兴趣，后续可以出更多的设计模式和Spring等框架结合使用的最佳实践。希望通过这样的文章，读者可以真正的在代码中使用上设计模式。</p>
<p>作者：漫话编程<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903974525468680">https://juejin.cn/post/6844903974525468680</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/07/%E7%AD%96%E7%95%A5+%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3if-else/" data-id="cm42pghe70005ogsl4c9qf1rv" data-title="策略+工厂模式解决if-else" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-8 个线程池最佳实践和坑！使用不当直接生产事故！！" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/06/8%20%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%9D%91%EF%BC%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E7%9B%B4%E6%8E%A5%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%EF%BC%81%EF%BC%81/" class="article-date">
  <time class="dt-published" datetime="2024-10-05T21:23:41.000Z" itemprop="datePublished">2024-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/10/06/8%20%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%9D%91%EF%BC%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E7%9B%B4%E6%8E%A5%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%EF%BC%81%EF%BC%81/">8 个线程池最佳实践和坑！使用不当直接生产事故！！</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-正确声明线程池"><a href="#1-正确声明线程池" class="headerlink" title="1. 正确声明线程池"></a>1. 正确声明线程池</h2><p>线程池必须手动通过 ThreadPoolExecutor 的构造函数来声明，避免使用Executors 类创建线程池，会有 OOM 风险。</p>
<p>Executors 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> ：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><code>CachedThreadPool</code> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><code>ScheduledThreadPool</code>和 <code>SingleThreadScheduledExecutor</code> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<p>说白了就是：使用有界队列，控制线程创建数量。</p>
<p>除了避免 OOM 的原因之外，不推荐使用 Executors提供的两种快捷的线程池的原因还有：</p>
<ul>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ul>
<h2 id="2-监测线程池运行状态"><a href="#2-监测线程池运行状态" class="headerlink" title="2.监测线程池运行状态"></a>2.监测线程池运行状态</h2><p>你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。</p>
<p>除此之外，我们还可以利用 ThreadPoolExecutor 的相关 API 做一个简陋的监控。从下图可以看出， ThreadPoolExecutor提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</p>
<p><img src="/images/ThreadPoolExecutor%E7%9B%B8%E5%85%B3API.png" alt="img"></p>
<p>下面是一个简单的 Demo。printThreadPoolStatus()会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程池的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadPool 线程池对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printThreadPoolStatus</span><span class="params">(ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, createThreadFactory(<span class="string">&quot;print-images/thread-pool-status&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());</span><br><span class="line">        log.info(<span class="string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-建议不同类别的业务用不同的线程池"><a href="#3-建议不同类别的业务用不同的线程池" class="headerlink" title="3.建议不同类别的业务用不同的线程池"></a>3.建议不同类别的业务用不同的线程池</h2><p>很多人在实际项目中都会有类似这样的问题：<strong>我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？</strong></p>
<p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。</p>
<p>我们再来看一个真实的事故案例！(本案例来源自：《线程池运用不当的一次线上事故》[1] ，很精彩的一个案例)</p>
<p><img src="/images/%E7%88%B6%E4%BB%BB%E5%8A%A1%E5%AD%90%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BA%8B%E6%95%85.png" alt="img"></p>
<p>上面的代码可能会存在死锁的情况，为什么呢？画个图给大家捋一捋。</p>
<p>试想这样一种极端情况：假如我们线程池的核心线程数为 n，父任务（扣费任务）数量为 n，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 “死锁”.</p>
<p><img src="/images/%E7%88%B6%E4%BB%BB%E5%8A%A1%E5%AD%90%E4%BB%BB%E5%8A%A1%E5%90%8C%E4%B8%80%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81.png" alt="img"></p>
<p>线程池使用不当导致死锁</p>
<p>解决方法也很简单，就是新增加一个用于执行子任务的线程池专门为其服务。</p>
<h2 id="4-别忘记给线程池命名"><a href="#4-别忘记给线程池命名" class="headerlink" title="4. 别忘记给线程池命名"></a>4. 别忘记给线程池命名</h2><p>初始化线程池的时候需要显示命名（设置线程池名称前缀），有利于定位问题。</p>
<p>默认情况下创建的线程名字类似 pool-1-thread-n 这样的，没有业务含义，不利于我们定位问题。</p>
<p>给线程池里的线程命名通常有下面两种方式：</p>
<p><strong>1、利用 guava 的 ThreadFactoryBuilder</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure>

<p><strong>2、自己实现 ThreadFactory。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-正确配置线程池参数"><a href="#5-正确配置线程池参数" class="headerlink" title="5.正确配置线程池参数"></a>5.正确配置线程池参数</h2><p>说到如何给线程池配置参数，美团的骚操作至今让我难忘（后面会提到）！</p>
<p>我们先来看一下各种书籍和博客上一般推荐的配置线程池参数的方式，可以作为参考！</p>
<p><strong>常规操作</strong></p>
<p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了上下文切换成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>
<ul>
<li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li>
<li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li>
</ul>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li>CPU 密集型任务(N+1)：这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li>I&#x2F;O 密集型任务(2N)：这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<p>🌈 拓展一下：</p>
<p>线程数更严谨的计算的方法应该是：最佳线程数 &#x3D; N（CPU 核心数）∗（1+WT（线程等待时间）&#x2F;ST（线程计算时间）），其中 WT（线程等待时间）&#x3D;线程运行总时间 - ST（线程计算时间）。</p>
<p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p>
<p>我们可以通过 JDK 自带的工具 VisualVM 来查看 WT&#x2F;ST 比例。</p>
<p>CPU 密集型任务的 WT&#x2F;ST 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）&#x3D; N，和我们上面说的 N（CPU 核心数）+1 差不多。</p>
<p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT&#x2F;ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p>
<p>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！</p>
<p><strong>美团的骚操作</strong></p>
<p>美团技术团队在《Java 线程池实现原理及其在美团业务中的实践》[3]这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p>
<p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p>
<ul>
<li>corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><strong>为什么是这三个参数？</strong></p>
<p>如何支持参数动态配置？且看 ThreadPoolExecutor 提供的下面这些方法。</p>
<p><img src="/images/ThreadPoolExecutor%E6%94%B9%E9%80%A0%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE.png" alt="img"></p>
<p>格外需要注意的是corePoolSize， 程序运行期间的时候，我们调用 setCorePoolSize（）这个方法的话，线程池会首先判断当前工作线程数是否大于corePoolSize，如果大于的话就会回收工作线程。</p>
<p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把LinkedBlockingQueue的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p>
<p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p>
<p><img src="/images/%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0.png" alt="img"></p>
<p>动态配置线程池参数最终效果</p>
<p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p>
<ul>
<li>Hippo-4[4] ：一款强大的动态线程池框架，解决了传统线程池使用存在的一些痛点比如线程池参数没办法动态修改、不支持运行时变量的传递、无法执行优雅关闭。除了支持动态修改线程池参数、线程池任务传递上下文，还支持通知报警、运行监控等开箱即用的功能。</li>
<li>Dynamic TP[5] ：轻量级动态线程池，内置监控告警功能，集成三方<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tdmq?from_column=20065&from=20065">中间件</a>线程池管理，基于主流<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/tse?from_column=20065&from=20065">配置中心</a>（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）。</li>
</ul>
<h2 id="6-线程池使用的一些小坑"><a href="#6-线程池使用的一些小坑" class="headerlink" title="6.线程池使用的一些小坑"></a>6.线程池使用的一些小坑</h2><p><strong>重复创建线程池的坑</strong></p>
<p>线程池是可以复用的，一定不要频繁创建线程池比如一个用户请求到了就单独创建一个线程池。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">GetMapping</span>(<span class="string">&quot;wrong&quot;</span>)</span><br><span class="line">public <span class="title class_">String</span> <span class="title function_">wrong</span>() throws <span class="title class_">InterruptedException</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义线程池</span></span><br><span class="line">    <span class="title class_">ThreadPoolExecutor</span> executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,1L,<span class="title class_">TimeUnit</span>.<span class="property">SECONDS</span>,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.<span class="title class_">CallerRunsPolicy</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理任务</span></span><br><span class="line">    executor.<span class="title function_">execute</span>(() -&gt; &#123;</span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现这种问题的原因还是对于线程池认识不够，需要加强线程池的基础知识。</p>
<p><strong>Spring 内部线程池的坑</strong></p>
<p>使用 Spring 内部线程池时，一定要手动自定义线程池，配置合理的参数，不然会出现生产问题（一个请求创建一个线程）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Configuration</span></span><br><span class="line">@<span class="title class_">EnableAsync</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="title class_">Bean</span>(name=<span class="string">&quot;threadPoolExecutor&quot;</span>)</span><br><span class="line">    public <span class="title class_">Executor</span> <span class="title function_">threadPoolExecutor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">ThreadPoolTaskExecutor</span> threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        int processNum = <span class="title class_">Runtime</span>.<span class="title function_">getRuntime</span>().<span class="title function_">availableProcessors</span>(); <span class="comment">// 返回可用处理器的Java虚拟机的数量</span></span><br><span class="line">        int corePoolSize = (int) (processNum / (<span class="number">1</span> - <span class="number">0.2</span>));</span><br><span class="line">        int maxPoolSize = (int) (processNum / (<span class="number">1</span> - <span class="number">0.5</span>));</span><br><span class="line">        threadPoolExecutor.<span class="title function_">setCorePoolSize</span>(corePoolSize); <span class="comment">// 核心池大小</span></span><br><span class="line">        threadPoolExecutor.<span class="title function_">setMaxPoolSize</span>(maxPoolSize); <span class="comment">// 最大线程数</span></span><br><span class="line">        threadPoolExecutor.<span class="title function_">setQueueCapacity</span>(maxPoolSize * <span class="number">1000</span>); <span class="comment">// 队列程度</span></span><br><span class="line">        threadPoolExecutor.<span class="title function_">setThreadPriority</span>(<span class="title class_">Thread</span>.<span class="property">MAX_PRIORITY</span>);</span><br><span class="line">        threadPoolExecutor.<span class="title function_">setDaemon</span>(<span class="literal">false</span>);</span><br><span class="line">        threadPoolExecutor.<span class="title function_">setKeepAliveSeconds</span>(<span class="number">300</span>);<span class="comment">// 线程空闲时间</span></span><br><span class="line">        threadPoolExecutor.<span class="title function_">setThreadNamePrefix</span>(<span class="string">&quot;test-Executor-&quot;</span>); <span class="comment">// 线程名字前缀</span></span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池和 ThreadLocal 共用的坑</strong></p>
<p>线程池和 ThreadLocal共用，可能会导致线程从ThreadLocal获取到的是旧值&#x2F;脏数据。这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 ThreadLocal 变量也会被重用，这就导致一个线程可能获取到其他线程的ThreadLocal 值。</p>
<p>不要以为代码中没有显示使用线程池就不存在线程池了，像常用的 Web <a target="_blank" rel="noopener" href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065">服务器</a> Tomcat 处理任务为了提高并发量，就使用到了线程池，并且使用的是基于原生 Java 线程池改进完善得到的自定义线程池。</p>
<p>当然了，你可以将 Tomcat 设置为单线程处理任务。不过，这并不合适，会严重影响其处理任务的速度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="property">tomcat</span>.<span class="property">max</span>-threads=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>解决上述问题比较建议的办法是使用阿里巴巴开源的 TransmittableThreadLocal(TTL)。TransmittableThreadLocal类继承并加强了 JDK 内置的InheritableThreadLocal类，在使用线程池等会池化复用线程的执行组件情况下，提供ThreadLocal值的传递功能，解决异步执行时上下文传递的问题。</p>
<p>InheritableThreadLocal 项目地址：<a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local">https://github.com/alibaba/transmittable-thread-local</a> 。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/06/8%20%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%9D%91%EF%BC%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E7%9B%B4%E6%8E%A5%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85%EF%BC%81%EF%BC%81/" data-id="cm42pghch0000ogslebegaal5" data-title="8 个线程池最佳实践和坑！使用不当直接生产事故！！" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/JAVA/" style="font-size: 20px;">JAVA</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 10px;">后端</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/29/%E7%BA%AF%E5%8E%9F%E7%94%9Fjs%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E4%BB%BB%E5%8A%A1%E7%9C%8B%E6%9D%BF/">纯原生js简单实现可拖拽任务看板</a>
          </li>
        
          <li>
            <a href="/2024/10/10/element-vue-admin%E5%89%8D%E7%AB%AFmock%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">element-vue-admin前端mock是如何实现的</a>
          </li>
        
          <li>
            <a href="/2024/10/08/Disruptor%E5%9C%A8%E6%92%AE%E5%90%88%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BD%9C%E5%BE%97%E7%89%A9%E6%8A%80%E6%9C%AF/">Disruptor在撮合引擎的实践｜得物技术</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E7%9A%847%E7%A7%8D%E5%8A%9E%E6%B3%95/">设置元素居中的7种办法</a>
          </li>
        
          <li>
            <a href="/2024/10/07/%E4%BB%8E%20synchronized%20%E5%88%B0%20CAS%20%E5%92%8C%20AQS%20-%20%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%20Java%20%E5%90%84%E7%A7%8D%E5%B9%B6%E5%8F%91%E9%94%81/">从 synchronized 到 CAS 和 AQS - 彻底弄懂 Java 各种并发锁</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 haipeiface<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>